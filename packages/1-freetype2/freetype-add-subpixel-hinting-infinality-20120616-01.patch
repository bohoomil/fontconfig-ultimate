diff -Nur freetype-orig/devel/ftoption.h freetype-subpixel/devel/ftoption.h
--- freetype-orig/devel/ftoption.h	2012-06-14 00:35:57.000000000 -0500
+++ freetype-subpixel/devel/ftoption.h	2012-06-15 07:31:12.119986648 -0500
@@ -560,6 +560,28 @@
 
   /*************************************************************************/
   /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
+  /* EXPERIMENTAL subpixel hinting support into the TrueType driver.  This */
+  /* replaces the native TrueType hinting mechanism when anything but      */
+  /* FT_RENDER_MODE_MONO is requested.                                     */
+  /*                                                                       */
+  /* Enabling this causes the TrueType driver to ignore instructions under */
+  /* certain conditions.  This is done in accordance with the guide here,  */
+  /* with some minor differences:                                          */
+  /*                                                                       */
+  /*  http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
+  /*                                                                       */
+  /* By undefining this, you only compile the code necessary to hint       */
+  /* TrueType glyphs with native TT hinting.                               */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be    */
+  /*   defined.                                                            */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
+
+  /*************************************************************************/
+  /*                                                                       */
   /* If you define TT_CONFIG_OPTION_UNPATENTED_HINTING, a special version  */
   /* of the TrueType bytecode interpreter is used that doesn't implement   */
   /* any of the patented opcodes and algorithms.  The patents related to   */
diff -Nur freetype-orig/include/freetype/config/ftoption.h freetype-subpixel/include/freetype/config/ftoption.h
--- freetype-orig/include/freetype/config/ftoption.h	2012-06-14 00:35:58.000000000 -0500
+++ freetype-subpixel/include/freetype/config/ftoption.h	2012-06-15 07:31:12.146985731 -0500
@@ -560,6 +560,28 @@
 
   /*************************************************************************/
   /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
+  /* EXPERIMENTAL subpixel hinting support into the TrueType driver.  This */
+  /* replaces the native TrueType hinting mechanism when anything but      */
+  /* FT_RENDER_MODE_MONO is requested.                                     */
+  /*                                                                       */
+  /* Enabling this causes the TrueType driver to ignore instructions under */
+  /* certain conditions.  This is done in accordance with the guide here,  */
+  /* with some minor differences:                                          */
+  /*                                                                       */
+  /*  http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
+  /*                                                                       */
+  /* By undefining this, you only compile the code necessary to hint       */
+  /* TrueType glyphs with native TT hinting.                               */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be    */
+  /*   defined.                                                            */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
+
+  /*************************************************************************/
+  /*                                                                       */
   /* If you define TT_CONFIG_OPTION_UNPATENTED_HINTING, a special version  */
   /* of the TrueType bytecode interpreter is used that doesn't implement   */
   /* any of the patented opcodes and algorithms.  The patents related to   */
diff -Nur freetype-orig/include/freetype/internal/ftobjs.h freetype-subpixel/include/freetype/internal/ftobjs.h
--- freetype-orig/include/freetype/internal/ftobjs.h	2012-06-14 00:35:58.000000000 -0500
+++ freetype-subpixel/include/freetype/internal/ftobjs.h	2012-06-15 07:31:12.147985698 -0500
@@ -81,6 +81,14 @@
 #define FT_PIX_ROUND( x )     FT_PIX_FLOOR( (x) + 32 )
 #define FT_PIX_CEIL( x )      FT_PIX_FLOOR( (x) + 63 )
 
+  /*
+   *  These are used in ttinterp.c for subpixel hinting with an
+   *  adjustable grids-per-pixel value.
+   */
+#define FT_PIX_FLOOR_GRID( x, n )  ( (x) & ~( 64 / (n) - 1 ) )
+#define FT_PIX_ROUND_GRID( x, n )  FT_PIX_FLOOR_GRID( (x) + 32 / (n), (n) )
+#define FT_PIX_CEIL_GRID( x, n )   FT_PIX_FLOOR_GRID( (x) + 63 / (n), (n) )
+
 
   /*
    *  Return the highest power of 2 that is <= value; this correspond to
diff -Nur freetype-orig/src/truetype/rules.mk freetype-subpixel/src/truetype/rules.mk
--- freetype-orig/src/truetype/rules.mk	2011-01-03 00:06:51.000000000 -0600
+++ freetype-subpixel/src/truetype/rules.mk	2012-06-15 07:31:12.148985665 -0500
@@ -31,7 +31,8 @@
               $(TT_DIR)/ttinterp.c \
               $(TT_DIR)/ttobjs.c   \
               $(TT_DIR)/ttpic.c    \
-              $(TT_DIR)/ttpload.c
+              $(TT_DIR)/ttpload.c  \
+              $(TT_DIR)/ttsubpix.c
 
 # TrueType driver headers
 #
diff -Nur freetype-orig/src/truetype/truetype.c freetype-subpixel/src/truetype/truetype.c
--- freetype-orig/src/truetype/truetype.c	2009-07-03 08:28:24.000000000 -0500
+++ freetype-subpixel/src/truetype/truetype.c	2012-06-15 07:31:12.149985631 -0500
@@ -27,6 +27,7 @@
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 #include "ttinterp.c"
+#include "ttsubpix.c"
 #endif
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
diff -Nur freetype-orig/src/truetype/ttgload.c freetype-subpixel/src/truetype/ttgload.c
--- freetype-orig/src/truetype/ttgload.c	2012-06-14 00:35:58.000000000 -0500
+++ freetype-subpixel/src/truetype/ttgload.c	2012-06-15 07:31:12.151985563 -0500
@@ -32,6 +32,7 @@
 #endif
 
 #include "tterrors.h"
+#include "ttsubpix.h"
 
 
   /*************************************************************************/
@@ -149,6 +150,15 @@
     loader->top_bearing  = top_bearing;
     loader->vadvance     = advance_height;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( loader->exec )
+      loader->exec->sph_tweak_flags = 0;
+
+    /* this may not be the right place for this, but it works */
+    if ( loader->exec && loader->exec->ignore_x_mode )
+      sph_set_tweaks( loader, glyph_index );
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     if ( !loader->linear_def )
     {
       loader->linear_def = 1;
@@ -813,6 +823,13 @@
       loader->pp4 = zone->cur[zone->n_points - 1];
     }
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if  ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )
+      FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );
+
+    else if  ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )
+      FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
+#endif
     return TT_Err_Ok;
   }
 
@@ -835,6 +852,13 @@
     FT_Outline*     outline;
     FT_Int          n_points;
 
+    TT_Face     face   = (TT_Face)loader->face;
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_String*  family = face->root.family_name;
+    int         ppem   = loader->size->metrics.x_ppem;
+    FT_String*  style  = face->root.style_name;
+    float       x_scale_factor = 1.0;
+#endif
 
     outline  = &gloader->current.outline;
     n_points = outline->n_points;
@@ -889,6 +913,26 @@
                      loader->zone.n_points + 4 );
     }
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    /* scale, but only if enabled and only if TT hinting is being used */
+    if ( IS_HINTED( loader->load_flags ) )
+      x_scale_factor = scale_test_tweak( face, family, ppem, style,
+                                         loader->glyph_index, X_SCALING_Rules,
+                                         X_SCALING_RULES_SIZE );
+    /* scale the glyph */
+    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0                  ||
+         x_scale_factor != 1.0 )
+    {
+      FT_Vector*  vec     = outline->points;
+      FT_Vector*  limit   = outline->points + n_points;
+      FT_Fixed    x_scale = ((TT_Size)loader->size)->metrics.x_scale * x_scale_factor;
+      FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;
+
+      /* compensate for any scaling by de/emboldening */
+      if ( x_scale_factor != 1.0 && ppem > 11 )
+        FT_Outline_EmboldenXY( outline,
+                (FT_Int) ( 16.0 * (float)ppem * ( 1.0 - x_scale_factor) ), 0 );
+#else
     /* scale the glyph */
     if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
     {
@@ -896,7 +940,7 @@
       FT_Vector*  limit   = outline->points + n_points;
       FT_Fixed    x_scale = ((TT_Size)loader->size)->metrics.x_scale;
       FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;
-
+#endif
 
       for ( ; vec < limit; vec++ )
       {
@@ -1648,12 +1692,26 @@
     {
       FT_Byte*  widthp;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      FT_Bool   ignore_x_mode;
+
+
+      ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=
+                          FT_RENDER_MODE_MONO );
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
       widthp = tt_face_get_device_metrics( face,
                                            size->root.metrics.x_ppem,
                                            glyph_index );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      if ( widthp &&
+           ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
+              !ignore_x_mode                                      ||
+              SPH_OPTION_BITMAP_WIDTHS ) )
+#else
       if ( widthp )
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
         glyph->metrics.horiAdvance = *widthp << 6;
     }
 
@@ -1848,6 +1906,15 @@
     {
       TT_ExecContext  exec;
       FT_Bool         grayscale;
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      FT_Bool         subpixel_hinting;
+      FT_Bool         grayscale_hinting;
+#if 0
+      FT_Bool         compatible_widths;
+      FT_Bool         symmetrical_smoothing;
+      FT_Bool         bgr;
+#endif
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
 
       if ( !size->cvt_ready )
@@ -1865,11 +1932,88 @@
       if ( !exec )
         return TT_Err_Could_Not_Find_Context;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+
+      subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags )
+                                    != FT_RENDER_MODE_MONO )          &&
+                                  SPH_OPTION_SET_SUBPIXEL             );
+
+      if ( subpixel_hinting )
+        grayscale = grayscale_hinting = FALSE;
+
+      else if ( SPH_OPTION_SET_GRAYSCALE )
+      {
+        grayscale = grayscale_hinting = TRUE;
+        subpixel_hinting = FALSE;
+      }
+
+      if ( FT_IS_TRICKY( glyph->face ) )
+      {
+        subpixel_hinting = grayscale_hinting = FALSE;
+      }
+
+      exec->ignore_x_mode      = subpixel_hinting || grayscale_hinting;
+      exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
+      if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
+        exec->rasterizer_version = 35;
+
+#if 1
+      exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
+      exec->symmetrical_smoothing = FALSE;
+      exec->bgr                   = FALSE;
+#else /* 0 */
+      exec->compatible_widths =
+        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
+                 TT_LOAD_COMPATIBLE_WIDTHS );
+      exec->symmetrical_smoothing =
+        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
+                 TT_LOAD_SYMMETRICAL_SMOOTHING );
+      exec->bgr =
+        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
+                 TT_LOAD_BGR );
+#endif /* 0 */
+
+#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
       grayscale =
         FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_RENDER_MODE_MONO );
 
+#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
       TT_Load_Context( exec, face, size );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+
+      /* a change from mono to subpixel rendering (and vice versa) */
+      /* requires a re-execution of the CVT program                */
+      if ( subpixel_hinting != exec->subpixel_hinting )
+      {
+        FT_UInt  i;
+
+
+        exec->subpixel_hinting = subpixel_hinting;
+
+        for ( i = 0; i < size->cvt_size; i++ )
+          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
+        tt_size_run_prep( size, pedantic );
+      }
+
+      /* a change from mono to grayscale rendering (and vice versa) */
+      /* requires a re-execution of the CVT program                 */
+      if ( grayscale != exec->grayscale_hinting )
+      {
+        FT_UInt  i;
+
+
+        exec->grayscale_hinting = grayscale_hinting;
+
+        for ( i = 0; i < size->cvt_size; i++ )
+          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
+        tt_size_run_prep( size, pedantic );
+      }
+
+#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
       /* a change from mono to grayscale rendering (and vice versa) */
       /* requires a re-execution of the CVT program                 */
       if ( grayscale != exec->grayscale )
@@ -1887,6 +2031,8 @@
         tt_size_run_prep( size, pedantic );
       }
 
+#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
       /* see whether the cvt program has disabled hinting */
       if ( exec->GS.instruct_control & 1 )
         load_flags |= FT_LOAD_NO_HINTING;
diff -Nur freetype-orig/src/truetype/ttinterp.c freetype-subpixel/src/truetype/ttinterp.c
--- freetype-orig/src/truetype/ttinterp.c	2012-06-14 00:35:58.000000000 -0500
+++ freetype-subpixel/src/truetype/ttinterp.c	2012-06-16 10:31:47.161209856 -0500
@@ -27,13 +27,16 @@
 #include FT_SYSTEM_H
 
 #include "ttinterp.h"
-
 #include "tterrors.h"
+#include "ttsubpix.h"
 
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
 
+#define xxxSPH_DEBUG
+#define xxxSPH_DEBUG_MORE_VERBOSE
+
 #define TT_MULFIX           FT_MulFix
 #define TT_MULDIV           FT_MulDiv
 #define TT_MULDIV_NO_ROUND  FT_MulDiv_No_Round
@@ -153,11 +156,11 @@
 #define NORMalize( x, y, v ) \
           Normalize( EXEC_ARG_ x, y, v )
 
-#define SET_SuperRound( scale, flags ) \
-          SetSuperRound( EXEC_ARG_ scale, flags )
+#define SET_SuperRound( scale, flags, res ) \
+          SetSuperRound( EXEC_ARG_ scale, flags, res )
 
-#define ROUND_None( d, c ) \
-          Round_None( EXEC_ARG_ d, c )
+#define ROUND_None( d, c, e ) \
+          Round_None( EXEC_ARG_ d, c, e )
 
 #define INS_Goto_CodeRange( range, ip ) \
           Ins_Goto_CodeRange( EXEC_ARG_ range, ip )
@@ -168,8 +171,8 @@
 #define CUR_Func_move_orig( z, p, d ) \
           CUR.func_move_orig( EXEC_ARG_ z, p, d )
 
-#define CUR_Func_round( d, c ) \
-          CUR.func_round( EXEC_ARG_ d, c )
+#define CUR_Func_round( d, c, e ) \
+          CUR.func_round( EXEC_ARG_ d, c, e )
 
 #define CUR_Func_read_cvt( index ) \
           CUR.func_read_cvt( EXEC_ARG_ index )
@@ -1850,6 +1853,10 @@
 
     if ( v != 0 )
     {
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      if ( !CUR.ignore_x_mode                                         ||
+          ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVE ) )
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
       zone->cur[point].x += TT_MULDIV( distance,
                                        v * 0x10000L,
                                        CUR.F_dot_P );
@@ -1932,6 +1939,10 @@
   {
     FT_UNUSED_EXEC;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( !CUR.ignore_x_mode                                           ||
+         ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVEX ) )
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
     zone->cur[point].x += distance;
     zone->tags[point]  |= FT_CURVE_TAG_TOUCH_X;
   }
@@ -1994,6 +2005,8 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    The compensated distance.                                          */
   /*                                                                       */
@@ -2005,11 +2018,13 @@
   /*                                                                       */
   static FT_F26Dot6
   Round_None( EXEC_OP_ FT_F26Dot6  distance,
-                       FT_F26Dot6  compensation )
+                       FT_F26Dot6  compensation,
+                       FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
     FT_UNUSED_EXEC;
+    FT_UNUSED( resolution );
 
 
     if ( distance >= 0 )
@@ -2024,6 +2039,7 @@
       if ( val > 0 )
         val = 0;
     }
+
     return val;
   }
 
@@ -2041,12 +2057,15 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
-                          FT_F26Dot6  compensation )
+                          FT_F26Dot6  compensation,
+                          FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
@@ -2055,15 +2074,15 @@
 
     if ( distance >= 0 )
     {
-      val = distance + compensation + 32;
+      val = distance + compensation + 32 / resolution;
       if ( distance && val > 0 )
-        val &= ~63;
+        val &= ~( 64 / resolution - 1 );
       else
         val = 0;
     }
     else
     {
-      val = -FT_PIX_ROUND( compensation - distance );
+      val = -FT_PIX_ROUND_GRID( compensation - distance, resolution );
       if ( val > 0 )
         val = 0;
     }
@@ -2085,12 +2104,15 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_To_Half_Grid( EXEC_OP_ FT_F26Dot6  distance,
-                               FT_F26Dot6  compensation )
+                               FT_F26Dot6  compensation,
+                               FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
@@ -2099,13 +2121,15 @@
 
     if ( distance >= 0 )
     {
-      val = FT_PIX_FLOOR( distance + compensation ) + 32;
+      val = FT_PIX_FLOOR_GRID( distance + compensation, resolution ) +
+            32 / resolution;
       if ( distance && val < 0 )
         val = 0;
     }
     else
     {
-      val = -( FT_PIX_FLOOR( compensation - distance ) + 32 );
+      val = -( FT_PIX_FLOOR_GRID( compensation - distance, resolution ) +
+               32 / resolution );
       if ( val > 0 )
         val = 0;
     }
@@ -2127,12 +2151,15 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_Down_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
-                               FT_F26Dot6  compensation )
+                               FT_F26Dot6  compensation,
+                               FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
@@ -2143,13 +2170,13 @@
     {
       val = distance + compensation;
       if ( distance && val > 0 )
-        val &= ~63;
+        val &= ~( 64 / resolution - 1 );
       else
         val = 0;
     }
     else
     {
-      val = -( ( compensation - distance ) & -64 );
+      val = -( ( compensation - distance ) & -( 64 / resolution ) );
       if ( val > 0 )
         val = 0;
     }
@@ -2171,12 +2198,15 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_Up_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
-                             FT_F26Dot6  compensation )
+                             FT_F26Dot6  compensation,
+                             FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
@@ -2185,15 +2215,15 @@
 
     if ( distance >= 0 )
     {
-      val = distance + compensation + 63;
+      val = distance + compensation + ( 64 / resolution - 1 );
       if ( distance && val > 0 )
-        val &= ~63;
+        val &= ~( 64 / resolution - 1 );
       else
         val = 0;
     }
     else
     {
-      val = - FT_PIX_CEIL( compensation - distance );
+      val = -FT_PIX_CEIL_GRID( compensation - distance, resolution );
       if ( val > 0 )
         val = 0;
     }
@@ -2215,12 +2245,15 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_To_Double_Grid( EXEC_OP_ FT_F26Dot6  distance,
-                                 FT_F26Dot6  compensation )
+                                 FT_F26Dot6  compensation,
+                                 FT_Int      resolution )
   {
     FT_F26Dot6 val;
 
@@ -2229,15 +2262,15 @@
 
     if ( distance >= 0 )
     {
-      val = distance + compensation + 16;
+      val = distance + compensation + 16 / resolution;
       if ( distance && val > 0 )
-        val &= ~31;
+        val &= ~( 32 / resolution - 1 );
       else
         val = 0;
     }
     else
     {
-      val = -FT_PAD_ROUND( compensation - distance, 32 );
+      val = -FT_PAD_ROUND( compensation - distance, 32 / resolution );
       if ( val > 0 )
         val = 0;
     }
@@ -2259,6 +2292,8 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
@@ -2270,10 +2305,13 @@
   /*                                                                       */
   static FT_F26Dot6
   Round_Super( EXEC_OP_ FT_F26Dot6  distance,
-                        FT_F26Dot6  compensation )
+                        FT_F26Dot6  compensation,
+                        FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
+    FT_UNUSED( resolution );
+
 
     if ( distance >= 0 )
     {
@@ -2309,6 +2347,8 @@
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
+  /*    resolution   :: The number of grid lines per pixel.                */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
@@ -2318,10 +2358,13 @@
   /*                                                                       */
   static FT_F26Dot6
   Round_Super_45( EXEC_OP_ FT_F26Dot6  distance,
-                           FT_F26Dot6  compensation )
+                           FT_F26Dot6  compensation,
+                           FT_Int      resolution )
   {
     FT_F26Dot6  val;
 
+    FT_UNUSED( resolution );
+
 
     if ( distance >= 0 )
     {
@@ -2404,13 +2447,19 @@
   /*    Sets Super Round parameters.                                       */
   /*                                                                       */
   /* <Input>                                                               */
-  /*    GridPeriod :: Grid period                                          */
-  /*    selector   :: SROUND opcode                                        */
+  /*    GridPeriod :: The grid period.                                     */
+  /*                                                                       */
+  /*    selector   :: The SROUND opcode.                                   */
+  /*                                                                       */
+  /*    resolution :: The number of grid lines per pixel.                  */
   /*                                                                       */
   static void
   SetSuperRound( EXEC_OP_ FT_F26Dot6  GridPeriod,
-                          FT_Long     selector )
+                          FT_Long     selector,
+                          FT_Int      resolution )
   {
+    FT_UNUSED( resolution );
+
     switch ( (FT_Int)( selector & 0xC0 ) )
     {
       case 0:
@@ -3080,13 +3129,13 @@
 
 
 #define DO_SROUND                                \
-    SET_SuperRound( 0x4000, args[0] );           \
+    SET_SuperRound( 0x4000, args[0], 1 );        \
     CUR.GS.round_state = TT_Round_Super;         \
     CUR.func_round = (TT_Round_Func)Round_Super;
 
 
 #define DO_S45ROUND                                 \
-    SET_SuperRound( 0x2D41, args[0] );              \
+    SET_SuperRound( 0x2D41, args[0], 1 );           \
     CUR.GS.round_state = TT_Round_Super_45;         \
     CUR.func_round = (TT_Round_Func)Round_Super_45;
 
@@ -3257,12 +3306,12 @@
     args[0] = ( args[0] != args[1] );
 
 
-#define DO_ODD                                                  \
-    args[0] = ( ( CUR_Func_round( args[0], 0 ) & 127 ) == 64 );
+#define DO_ODD                                                     \
+    args[0] = ( ( CUR_Func_round( args[0], 0, 1 ) & 127 ) == 64 );
 
 
-#define DO_EVEN                                                \
-    args[0] = ( ( CUR_Func_round( args[0], 0 ) & 127 ) == 0 );
+#define DO_EVEN                                                   \
+    args[0] = ( ( CUR_Func_round( args[0], 0, 1 ) & 127 ) == 0 );
 
 
 #define DO_AND                        \
@@ -3311,6 +3360,34 @@
 #define DO_CEILING                    \
     args[0] = FT_PIX_CEIL( args[0] );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+
+#define DO_RS                                             \
+   {                                                      \
+     FT_ULong  I = (FT_ULong)args[0];                     \
+                                                          \
+                                                          \
+     if ( BOUNDSL( I, CUR.storeSize ) )                   \
+     {                                                    \
+       if ( CUR.pedantic_hinting )                        \
+         ARRAY_BOUND_ERROR;                               \
+       else                                               \
+         args[0] = 0;                                     \
+     }                                                    \
+     else                                                 \
+     {                                                    \
+       /* subpixel hinting - avoid Typeman Dstroke and */ \
+       /* IStroke and Vacuform rounds                  */ \
+                                                          \
+       if ( CUR.compatibility_mode                    &&  \
+            ( I == 24 || I == 22 || I == 8 ) )            \
+         args[0] = 0;                                     \
+       else                                               \
+         args[0] = CUR.storage[I];                        \
+     }                                                    \
+   }
+
+#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
 #define DO_RS                           \
    {                                    \
@@ -3330,6 +3407,8 @@
        args[0] = CUR.storage[I];        \
    }
 
+#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
 
 #define DO_WS                           \
    {                                    \
@@ -3405,15 +3484,17 @@
     CUR.error = TT_Err_Debug_OpCode;
 
 
-#define DO_ROUND                                                   \
-    args[0] = CUR_Func_round(                                      \
-                args[0],                                           \
-                CUR.tt_metrics.compensations[CUR.opcode - 0x68] );
+#define DO_ROUND                                                 \
+    args[0] = CUR_Func_round(                                    \
+                args[0],                                         \
+                CUR.tt_metrics.compensations[CUR.opcode - 0x68], \
+                1 );
 
 
-#define DO_NROUND                                                            \
-    args[0] = ROUND_None( args[0],                                           \
-                          CUR.tt_metrics.compensations[CUR.opcode - 0x6C] );
+#define DO_NROUND                                                          \
+    args[0] = ROUND_None( args[0],                                         \
+                          CUR.tt_metrics.compensations[CUR.opcode - 0x6C], \
+                          1 );
 
 
 #define DO_MAX               \
@@ -4587,6 +4668,24 @@
     TT_DefRecord*  rec;
     TT_DefRecord*  limit;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+#if 0
+    int  opcode_pattern[4][12] = {
+           /* VacuFormRound function */
+           {0x45,0x23,0x46,0x60,0x20},
+           /* inline delta function 1 */
+           {0x4B,0x53,0x23,0x4B,0x51,0x5A,0x58,0x38,0x1B,0x21,0x21,0x59},
+           /* inline delta function 2 */
+           {0x4B,0x54,0x58,0x38,0x1B,0x5A,0x21,0x21,0x59},
+           /* diagonal stroke function */
+           {0x20,0x20,0x40,0x60,0x47,0x40,0x23,0x42},
+         };
+    int  opcode_patterns = 4;
+    int  i;
+    int  opcode_pointer[4] = {0,0,0,0};
+#endif
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
 
     /* some font programs are broken enough to redefine functions! */
     /* We will then parse the current table.                       */
@@ -4620,10 +4719,11 @@
       return;
     }
 
-    rec->range  = CUR.curRange;
-    rec->opc    = (FT_UInt16)n;
-    rec->start  = CUR.IP + 1;
-    rec->active = TRUE;
+    rec->range        = CUR.curRange;
+    rec->opc          = (FT_UInt16)n;
+    rec->start        = CUR.IP + 1;
+    rec->active       = TRUE;
+    rec->inline_delta = FALSE;
 
     if ( n > CUR.maxFunc )
       CUR.maxFunc = (FT_UInt16)n;
@@ -4633,6 +4733,78 @@
 
     while ( SKIP_Code() == SUCCESS )
     {
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+#if 0
+#ifdef SPH_DEBUG_MORE_VERBOSE
+      printf ("Opcode: %d ", CUR.opcode);
+#endif
+
+      for ( i = 0; i < opcode_patterns; i++ )
+      {
+        if ( CUR.opcode == opcode_pattern[i][opcode_pointer[i]] )
+        {
+#ifdef SPH_DEBUG_MORE_VERBOSE
+          printf( "function %d, opcode ptrn: %d"
+                  "  op# %d: %d FOUND \n",
+                  n, i, opcode_pointer[i], CUR.opcode );
+#endif
+          opcode_pointer[i] += 1;
+
+          if ( i == 0 && opcode_pointer[0] == 5 )
+          {
+
+            CUR.inline_delta_funcs[CUR.num_delta_funcs] = n;
+            CUR.num_delta_funcs++;
+#ifdef SPH_DEBUG
+            printf( "Vacuform Round FUNCTION %d detected\n", n);
+#endif
+            /*rec->active = FALSE;*/
+            opcode_pointer[i] = 0;
+          }
+
+          if ( i == 1 && opcode_pointer[1] == 12 )
+          {
+            CUR.inline_delta_funcs[CUR.num_delta_funcs] = n;
+            CUR.num_delta_funcs++;
+#ifdef SPH_DEBUG
+            printf( "inline delta FUNCTION1 %d detected\n",
+                    n, CUR.num_delta_funcs);
+#endif
+            rec->inline_delta = TRUE;
+            opcode_pointer[i] = 0;
+          }
+
+          if ( i == 2 && opcode_pointer[1] == 9 )
+          {
+            CUR.inline_delta_funcs[CUR.num_delta_funcs] = n;
+            CUR.num_delta_funcs++;
+            rec->inline_delta = TRUE;
+#ifdef SPH_DEBUG
+            printf( "inline delta2 FUNCTION2 %d detected\n",
+                    n, CUR.num_delta_funcs);
+#endif
+            opcode_pointer[i] = 0;
+          }
+
+          if ( i == 4 && opcode_pointer[1] == 8 )
+          {
+            CUR.inline_delta_funcs[CUR.num_delta_funcs] = n;
+            CUR.num_delta_funcs++;
+            /*rec->active = FALSE;*/
+#ifdef SPH_DEBUG
+            printf( "diagonal stroke function %d detected\n",
+                    n, CUR.num_delta_funcs);
+#endif
+            opcode_pointer[i] = 0;
+          }
+        }
+
+        else
+          opcode_pointer[i] = 0;
+      }
+#endif
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
       switch ( CUR.opcode )
       {
       case 0x89:    /* IDEF */
@@ -4676,6 +4848,15 @@
 
     CUR.step_ins = FALSE;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    /*
+     *  CUR.ignore_x_mode may be turned off prior to function calls.  This
+     *  ensures it is turned back on.
+     */
+    CUR.ignore_x_mode = ( CUR.subpixel_hinting || CUR.grayscale_hinting )
+      && !( CUR.sph_tweak_flags & SPH_TWEAK_PIXEL_HINTING );
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     if ( pRec->Cur_Count > 0 )
     {
       CUR.callTop++;
@@ -4709,6 +4890,10 @@
     TT_CallRec*    pCrec;
     TT_DefRecord*  def;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_Bool        oldF;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
 
     /* first of all, check the index */
 
@@ -4746,6 +4931,20 @@
     if ( !def->active )
       goto Fail;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    /* This is test code used to detect inline delta functions */
+    oldF = def->inline_delta;
+    if ( CUR.ignore_x_mode )
+    {
+      if ( def->inline_delta )
+        CUR.in_delta_function = TRUE;
+    }
+
+#ifdef SPH_DEBUG
+      printf("Entering function %d\n", F);
+#endif
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     /* check the call stack */
     if ( CUR.callTop >= CUR.callSize )
     {
@@ -4767,6 +4966,13 @@
                         def->start );
 
     CUR.step_ins = FALSE;
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    CUR.in_delta_function = oldF;
+
+#ifdef SPH_DEBUG
+      printf("Leaving function %d\n", F);
+#endif
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
     return;
 
   Fail:
@@ -4787,6 +4993,10 @@
     TT_CallRec*    pCrec;
     TT_DefRecord*  def;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_Bool        oldF;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
 
     /* first of all, check the index */
     F = args[1];
@@ -4823,6 +5033,15 @@
     if ( !def->active )
       goto Fail;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    oldF = def->inline_delta;
+    if ( CUR.ignore_x_mode )
+    {
+      if ( def->inline_delta )
+        CUR.in_delta_function = TRUE;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     /* check stack */
     if ( CUR.callTop >= CUR.callSize )
     {
@@ -4846,6 +5065,11 @@
 
       CUR.step_ins = FALSE;
     }
+
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    CUR.in_delta_function = oldF;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     return;
 
   Fail:
@@ -5195,6 +5419,12 @@
       }
     }
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    /* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
+    if ( CUR.ignore_x_mode && FT_ABS( D ) == 64 )
+      D += 1;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     args[0] = D;
   }
 
@@ -5691,7 +5921,12 @@
 
     if ( CUR.GS.freeVector.x != 0 )
     {
-      CUR.zp2.cur[point].x += dx;
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      if ( !CUR.ignore_x_mode                                               ||
+          ( CUR.ignore_x_mode                                            &&
+            ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_MOVE_ZP2 ) ) )
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+        CUR.zp2.cur[point].x += dx;
       if ( touch )
         CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
     }
@@ -5872,6 +6107,9 @@
   {
     FT_F26Dot6  dx, dy;
     FT_UShort   point;
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_Int      B1, B2;
+#endif
 
 
     if ( CUR.top < CUR.GS.loop + 1 )
@@ -5917,7 +6155,77 @@
         }
       }
       else
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      {
+        /*  If not using ignore_x_mode rendering, allow ZP2 move.          */
+        /*  If inline deltas aren't allowed, skip ZP2 move.                */
+        /*  If using ignore_x_mode rendering, allow ZP2 point move if:     */
+        /*   - freedom vector is y and compatibility_mode is off           */
+        /*   - the glyph is composite and the move is in the Y direction   */
+        /*   - the glyph is specifically set to allow SHPIX moves          */
+        /*   - the move is on a previously Y-touched point                 */
+
+        if ( CUR.ignore_x_mode )
+        {
+          /* save point for later comparison */
+          if ( CUR.GS.freeVector.y != 0 )
+            B1 = CUR.zp2.cur[point].y;
+          else
+            B1 = CUR.zp2.cur[point].x;
+
+          if ( CUR.GS.freeVector.y != 0                                    &&
+               ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_INLINE_DELTAS ) )
+            goto Skip;
+
+          if ( CUR.ignore_x_mode                                           &&
+               !CUR.compatibility_mode && CUR.GS.freeVector.y != 0 )
+            MOVE_Zp2_Point( point, dx, dy, TRUE );
+
+          else if ( CUR.ignore_x_mode && CUR.compatibility_mode )
+          {
+            if ( CUR.ignore_x_mode                                         &&
+                ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
+            {
+              dx = FT_PIX_ROUND ( B1 + dx ) - B1;
+              dy = FT_PIX_ROUND ( B1 + dy ) - B1;
+            }
+
+            if ( !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP )   &&
+                  ( ( CUR.is_composite && CUR.GS.freeVector.y != 0 )     ||
+                    ( CUR.zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )       ||
+                    ( CUR.sph_tweak_flags & SPH_TWEAK_DO_SHPIX ) )
+               )
+              MOVE_Zp2_Point( point, dx, dy, TRUE );
+          }
+
+          /* save new point */
+          if ( CUR.GS.freeVector.y != 0 )
+            B2 = CUR.zp2.cur[point].y;
+          else B2 = CUR.zp2.cur[point].x;
+
+          /* reverse any disallowed moves */
+          if ( ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
+                 CUR.GS.freeVector.y != 0                                  &&
+                 B1 % 64 != 0                                              &&
+                 B2 % 64 != 0 && B1 != B2 )                                  ||
+               ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES ) &&
+                 CUR.GS.freeVector.y != 0                                  &&
+                 B1 % 64 == 0                                              &&
+                 B2 % 64 != 0 && B1 != B2 ) )
+          {
+#ifdef SPH_DEBUG
+            printf( "Reversing ZP2 move\n" );
+#endif
+            MOVE_Zp2_Point( point, -dx, -dy, TRUE );
+          }
+      }
+        else
+          MOVE_Zp2_Point( point, dx, dy, TRUE );
+      }
+  Skip:
+#else
         MOVE_Zp2_Point( point, dx, dy, TRUE );
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
       CUR.GS.loop--;
     }
@@ -5939,7 +6247,18 @@
   {
     FT_UShort   point;
     FT_F26Dot6  distance;
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_Int      gridlines_per_pixel = 1;
+
 
+    if ( CUR.ignore_x_mode )
+    {
+      if ( CUR.GS.freeVector.x != 0 )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_X;
+      else if ( CUR.GS.freeVector.y != 0 )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_Y;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
     point = (FT_UShort)args[0];
 
@@ -5963,6 +6282,15 @@
     distance = CUR_Func_project( CUR.zp1.cur + point,
                                  CUR.zp0.cur + CUR.GS.rp0 );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    /* subpixel hinting - make MSIRP respect CVT cut-in; */
+    if ( CUR.ignore_x_mode                              &&
+         CUR.GS.freeVector.x != 0                       &&
+         FT_ABS( distance - args[1] ) >=
+           CUR.GS.control_value_cutin / gridlines_per_pixel )
+      distance = args[1];
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     CUR_Func_move( &CUR.zp1, point, args[1] - distance );
 
     CUR.GS.rp1 = CUR.GS.rp0;
@@ -5985,7 +6313,21 @@
     FT_UShort   point;
     FT_F26Dot6  cur_dist,
                 distance;
+    FT_Int      gridlines_per_pixel = 1;
+
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode )
+    {
+      if ( CUR.GS.freeVector.x != 0                                    &&
+           !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_X;
+
+      else if ( CUR.GS.freeVector.y != 0                               &&
+                !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_Y;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
     point = (FT_UShort)args[0];
 
@@ -6000,7 +6342,8 @@
     {
       cur_dist = CUR_fast_project( &CUR.zp0.cur[point] );
       distance = CUR_Func_round( cur_dist,
-                                 CUR.tt_metrics.compensations[0] ) - cur_dist;
+                                 CUR.tt_metrics.compensations[0],
+                                 gridlines_per_pixel ) - cur_dist;
     }
     else
       distance = 0;
@@ -6025,8 +6368,22 @@
     FT_UShort   point;
     FT_F26Dot6  distance,
                 org_dist;
+    FT_Int      gridlines_per_pixel = 1;
 
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode )
+    {
+      if ( CUR.GS.freeVector.x != 0                                    &&
+           !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_X;
+
+      else if ( CUR.GS.freeVector.y != 0                               &&
+                !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_Y;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     cvtEntry = (FT_ULong)args[1];
     point    = (FT_UShort)args[0];
 
@@ -6062,21 +6419,34 @@
 
     if ( CUR.GS.gep0 == 0 )   /* If in twilight zone */
     {
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      /* only adjust legacy fonts x otherwise breaks Calibri italic */
+      if ( CUR.compatibility_mode )
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
       CUR.zp0.org[point].x = TT_MulFix14( (FT_UInt32)distance,
                                           CUR.GS.freeVector.x );
       CUR.zp0.org[point].y = TT_MulFix14( (FT_UInt32)distance,
                                           CUR.GS.freeVector.y ),
       CUR.zp0.cur[point]   = CUR.zp0.org[point];
     }
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      if ( distance > 0                                                &&
+           ( CUR.sph_tweak_flags & SPH_TWEAK_MIAP_HACK )               &&
+           CUR.GS.freeVector.y != 0 )
+        distance = 0 ;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
     org_dist = CUR_fast_project( &CUR.zp0.cur[point] );
 
     if ( ( CUR.opcode & 1 ) != 0 )   /* rounding and control cutin flag */
     {
-      if ( FT_ABS( distance - org_dist ) > CUR.GS.control_value_cutin )
+      if ( FT_ABS( distance - org_dist ) >
+             CUR.GS.control_value_cutin / gridlines_per_pixel )
         distance = org_dist;
 
-      distance = CUR_Func_round( distance, CUR.tt_metrics.compensations[0] );
+      distance = CUR_Func_round( distance,
+                                 CUR.tt_metrics.compensations[0],
+                                 gridlines_per_pixel );
     }
 
     CUR_Func_move( &CUR.zp0, point, distance - org_dist );
@@ -6098,6 +6468,24 @@
   {
     FT_UShort   point;
     FT_F26Dot6  org_dist, distance;
+    FT_Int      minimum_distance_factor = 64;
+    FT_Int      gridlines_per_pixel = 1;
+
+
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode )
+    {
+      if ( CUR.GS.freeVector.x != 0                                    &&
+           !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+      {
+        gridlines_per_pixel              = SPH_OPTION_GRIDLINES_PER_PIXEL_X;
+        minimum_distance_factor = 64 - gridlines_per_pixel / 3;
+      }
+      else if ( CUR.GS.freeVector.y != 0                               &&
+                !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_Y;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
 
     point = (FT_UShort)args[0];
@@ -6163,11 +6551,13 @@
     if ( ( CUR.opcode & 4 ) != 0 )
       distance = CUR_Func_round(
                    org_dist,
-                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
+                   CUR.tt_metrics.compensations[CUR.opcode & 3],
+                   gridlines_per_pixel );
     else
       distance = ROUND_None(
                    org_dist,
-                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
+                   CUR.tt_metrics.compensations[CUR.opcode & 3],
+                   gridlines_per_pixel );
 
     /* minimum distance flag */
 
@@ -6175,13 +6565,17 @@
     {
       if ( org_dist >= 0 )
       {
-        if ( distance < CUR.GS.minimum_distance )
-          distance = CUR.GS.minimum_distance;
+        if ( distance < FT_MulDiv( minimum_distance_factor,
+                                   CUR.GS.minimum_distance, 64 ) )
+          distance = FT_MulDiv( minimum_distance_factor,
+                                CUR.GS.minimum_distance, 64 );
       }
       else
       {
-        if ( distance > -CUR.GS.minimum_distance )
-          distance = -CUR.GS.minimum_distance;
+        if ( distance > -FT_MulDiv( minimum_distance_factor,
+                                    CUR.GS.minimum_distance, 64 ) )
+          distance = -FT_MulDiv( minimum_distance_factor,
+                                 CUR.GS.minimum_distance, 64 );
       }
     }
 
@@ -6218,10 +6612,37 @@
                 cur_dist,
                 org_dist;
 
+    FT_Int      minimum_distance_factor = 64;
+    FT_Int      gridlines_per_pixel = 1;
+
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_Int      B1;
+    FT_Int      B2;
+    FT_Bool     reverse_move = FALSE;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
 
     point    = (FT_UShort)args[0];
     cvtEntry = (FT_ULong)( args[1] + 1 );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode )
+    {
+      if ( CUR.GS.freeVector.x != 0                                    &&
+           !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+      {
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_X;
+        /* high value emboldens glyphs at lower ppems (< 14); */
+        /* Courier looks better with 52 --                    */
+        /* MS ClearType Rasterizer supposedly uses 32         */
+        minimum_distance_factor = 64 - gridlines_per_pixel / 3;
+      }
+
+      else if ( CUR.GS.freeVector.y != 0                               &&
+                !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        gridlines_per_pixel = SPH_OPTION_GRIDLINES_PER_PIXEL_Y;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
@@ -6237,6 +6658,10 @@
       cvt_dist = 0;
     else
       cvt_dist = CUR_Func_read_cvt( cvtEntry - 1 );
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+      if ( CUR.sph_tweak_flags & SPH_TWEAK_MIRP_CVT_ZERO )
+        cvt_dist = 0;
+#endif
 
     /* single width test */
 
@@ -6274,8 +6699,15 @@
       if ( ( org_dist ^ cvt_dist ) < 0 )
         cvt_dist = -cvt_dist;
     }
-
-    /* control value cutin and round */
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.GS.freeVector.y != 0                                        &&
+                ( CUR.sph_tweak_flags & SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )
+    {
+      if ( cur_dist < -64 ) cvt_dist -= 16;
+      else if ( cur_dist > 64  && cur_dist < 84) cvt_dist += 32;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+    /* control value cut-in and round */
 
     if ( ( CUR.opcode & 4 ) != 0 )
     {
@@ -6296,18 +6728,21 @@
         /*      `ttinst2.doc', version 1.66, is thus incorrect since  */
         /*      it implies `>=' instead of `>'.                       */
 
-        if ( FT_ABS( cvt_dist - org_dist ) > CUR.GS.control_value_cutin )
+        if ( FT_ABS( cvt_dist - org_dist ) >
+               CUR.GS.control_value_cutin / gridlines_per_pixel )
           cvt_dist = org_dist;
       }
 
       distance = CUR_Func_round(
                    cvt_dist,
-                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
+                   CUR.tt_metrics.compensations[CUR.opcode & 3],
+                   gridlines_per_pixel );
     }
     else
       distance = ROUND_None(
                    cvt_dist,
-                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
+                   CUR.tt_metrics.compensations[CUR.opcode & 3],
+                   gridlines_per_pixel );
 
     /* minimum distance test */
 
@@ -6315,18 +6750,63 @@
     {
       if ( org_dist >= 0 )
       {
-        if ( distance < CUR.GS.minimum_distance )
-          distance = CUR.GS.minimum_distance;
+        if ( distance < FT_MulDiv( minimum_distance_factor,
+                                   CUR.GS.minimum_distance, 64 ) )
+          distance = FT_MulDiv( minimum_distance_factor,
+                                CUR.GS.minimum_distance, 64 );
       }
       else
       {
-        if ( distance > -CUR.GS.minimum_distance )
-          distance = -CUR.GS.minimum_distance;
+        if ( distance > -FT_MulDiv( minimum_distance_factor,
+                                    CUR.GS.minimum_distance, 64 ) )
+          distance = -FT_MulDiv( minimum_distance_factor,
+                                 CUR.GS.minimum_distance, 64 );
       }
     }
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    B1 = CUR.zp1.cur[point].y;
+
+    /* Round moves if necessary */
+    if ( CUR.ignore_x_mode                                               &&
+         CUR.GS.freeVector.y != 0                                        &&
+         ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
+      distance = FT_PIX_ROUND( B1 + distance - cur_dist ) - B1 + cur_dist;
+
+    if ( CUR.GS.freeVector.y != 0      &&
+         ( CUR.opcode & 16 ) == 0      &&
+         ( CUR.opcode & 8 ) == 0       &&
+         ( CUR.sph_tweak_flags & SPH_TWEAK_COURIER_NEW_2_HACK ) )
+      distance +=64;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     CUR_Func_move( &CUR.zp1, point, distance - cur_dist );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    B2 = CUR.zp1.cur[point].y;
+
+    /* Reverse move if necessary */
+    if ( CUR.ignore_x_mode )
+    {
+      if ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES )     &&
+           CUR.GS.freeVector.y != 0 && B1 % 64 == 0 && B2 % 64 != 0 )
+        reverse_move = TRUE;
+
+      if ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES )     &&
+           CUR.GS.freeVector.y != 0 && B2 % 64 != 0 && B1 % 64 != 0 )
+        reverse_move = TRUE;
+
+      if ( ( CUR.sph_tweak_flags & SPH_TWEAK_DELTAP_SKIP_EXAGGERATED_VALUES ) &&
+           !reverse_move                                                 &&
+           abs ( B1 - B2 ) >= 64 )
+        reverse_move = TRUE;
+    }
+
+    if ( reverse_move )
+      CUR_Func_move( &CUR.zp1, point, -( distance - cur_dist ) );
+
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
   Fail:
     CUR.GS.rp1 = CUR.GS.rp0;
 
@@ -6350,8 +6830,14 @@
     FT_F26Dot6  distance;
 
     FT_UNUSED_ARG;
-
-
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode && CUR.iup_called                                &&
+         ( CUR.sph_tweak_flags & SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )
+    {
+      CUR.error = TT_Err_Invalid_Reference;
+      goto Fail;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
     if ( CUR.top < CUR.GS.loop ||
          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
     {
@@ -6846,6 +7332,15 @@
     contour = 0;
     point   = 0;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode )
+    {
+      CUR.iup_called = 1;
+      if ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_IUP )
+        return;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     do
     {
       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;
@@ -6915,7 +7410,9 @@
     FT_UShort  A;
     FT_ULong   C;
     FT_Long    B;
-
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    FT_UShort  B1, B2;
+#endif
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     /* Delta hinting is covered by US Patent 5159668. */
@@ -6988,7 +7485,67 @@
             B++;
           B = B * 64 / ( 1L << CUR.GS.delta_shift );
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+          /*
+           *  Allow delta move if
+           *
+           *  - not using ignore_x_mode rendering
+           *  - glyph is specifically set to allow it
+           *  - glyph is composite and freedom vector is not subpixel vector
+           */
+          if ( !CUR.ignore_x_mode                                        ||
+              ( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP )       ||
+              ( CUR.is_composite && CUR.GS.freeVector.y != 0 ))
+            CUR_Func_move( &CUR.zp0, A, B );
+
+          /* Otherwise apply subpixel hinting and compatibility mode rules */
+          else if ( CUR.ignore_x_mode )
+          {
+            if ( CUR.GS.freeVector.y != 0 )
+              B1 = CUR.zp0.cur[A].y;
+            else
+              B1 = CUR.zp0.cur[A].x;
+
+            /* Standard Subpixel Hinting:  Allow y move */
+            if ( !CUR.compatibility_mode && CUR.GS.freeVector.y != 0 )
+              CUR_Func_move( &CUR.zp0, A, B );
+
+            /* Compatibility Mode: Allow x or y move if point touched in
+                Y direction */
+            else if ( CUR.compatibility_mode                             &&
+                      !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ))
+            {
+              /* save the y value of the point now; compare after move */
+              B1 = CUR.zp0.cur[A].y;
+
+              if ( ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
+                B = FT_PIX_ROUND( B1 + B ) - B1;
+
+              /*
+              *  Allow delta move if using compatibility_mode, IUP has not
+              *  been called, and point is touched on Y.
+              */
+              if ( !CUR.iup_called                                       &&
+                  ( CUR.zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
+                CUR_Func_move( &CUR.zp0, A, B );
+            }
+            B2 = CUR.zp0.cur[A].y;
+
+            /* Reverse this move if it results in a disallowed move */
+            if ( CUR.GS.freeVector.y != 0                                &&
+                 ( ( ( CUR.sph_tweak_flags &
+                        SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES )            &&
+                        B1 % 64 == 0                                 &&
+                        B2 % 64 != 0 )                                 ||
+                   ( ( CUR.sph_tweak_flags &
+                        SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES )            &&
+                        B1 % 64 != 0                                 &&
+                        B2 % 64 != 0 )))
+              CUR_Func_move( &CUR.zp0, A, -B );
+          }
+#else
           CUR_Func_move( &CUR.zp0, A, B );
+#endif /* *TT_CONFIG_OPTION_SUBPIXEL_HINTING */
         }
       }
       else
@@ -7114,26 +7671,116 @@
   Ins_GETINFO( INS_ARG )
   {
     FT_Long  K;
-
-
     K = 0;
 
-    /* We return MS rasterizer version 1.7 for the font scaler. */
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    /********************************/
+    /* RASTERIZER VERSION           */
+    /* Selector Bit:  0             */
+    /* Return Bit(s): 0-7           */
+    /*                              */
+    if ( ( args[0] & 1 ) != 0 && CUR.ignore_x_mode )
+    {
+      K = CUR.rasterizer_version;
+#ifdef SPH_DEBUG_MORE_VERBOSE
+      printf(" SETTING AS %d\n", CUR.rasterizer_version );
+#endif
+    }
+    else
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
     if ( ( args[0] & 1 ) != 0 )
       K = 35;
 
-    /* Has the glyph been rotated? */
+    /********************************/
+    /* GLYPH ROTATED                */
+    /* Selector Bit:  1             */
+    /* Return Bit(s): 8             */
+    /*                              */
     if ( ( args[0] & 2 ) != 0 && CUR.tt_metrics.rotated )
       K |= 0x80;
 
-    /* Has the glyph been stretched? */
+    /********************************/
+    /* GLYPH STRETCHED              */
+    /* Selector Bit:  2             */
+    /* Return Bit(s): 9             */
+    /*                              */
     if ( ( args[0] & 4 ) != 0 && CUR.tt_metrics.stretched )
       K |= 1 << 8;
 
-    /* Are we hinting for grayscale? */
+    /********************************/
+    /* HINTING FOR GRAYSCALE        */
+    /* Selector Bit:  5             */
+    /* Return Bit(s): 12            */
+    /*                              */
     if ( ( args[0] & 32 ) != 0 && CUR.grayscale )
       K |= 1 << 12;
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode && CUR.rasterizer_version >= 35 )
+    {
+      /********************************/
+      /* HINTING FOR GRAYSCALE        */
+      /* Selector Bit:  5             */
+      /* Return Bit(s): 12            */
+      /*                              */
+      if ( ( args[0] & 32 ) != 0 && CUR.grayscale_hinting )
+        K |= 1 << 12;
+
+      /********************************/
+      /* HINTING FOR SUBPIXEL         */
+      /* Selector Bit:  6             */
+      /* Return Bit(s): 13            */
+      /*                              */
+      if ( ( args[0] & 64 ) != 0         &&
+           CUR.subpixel_hinting          &&
+           CUR.rasterizer_version >= 37 )
+      {
+        K |= 1 << 13;
+
+        /* the stuff below is irrelevant if subpixel_hinting is not set */
+
+        /********************************/
+        /* COMPATIBLE WIDTHS ENABLED    */
+        /* Selector Bit:  7             */
+        /* Return Bit(s): 14            */
+        /*                              */
+        /* Functionality still needs to be added */
+        if ( ( args[0] & 128 ) != 0 && CUR.compatible_widths )
+          K |= 1 << 14;
+
+        /********************************/
+        /* SYMMETRICAL SMOOTHING        */
+        /* Selector Bit:  8             */
+        /* Return Bit(s): 15            */
+        /*                              */
+        /* Functionality still needs to be added */
+        if ( ( args[0] & 256 ) != 0 && CUR.symmetrical_smoothing )
+          K |= 1 << 15;
+
+        /********************************/
+        /* HINTING FOR BGR?             */
+        /* Selector Bit:  9             */
+        /* Return Bit(s): 16            */
+        /*                              */
+        /* Functionality still needs to be added */
+        if ( ( args[0] & 512 ) != 0 && CUR.bgr )
+          K |= 1 << 16;
+
+        if ( CUR.rasterizer_version >= 38 )
+        {
+
+          /********************************/
+          /* SUBPIXEL POSITIONED?         */
+          /* Selector Bit:  10            */
+          /* Return Bit(s): 17            */
+          /*                              */
+          /* Functionality still needs to be added */
+          if ( ( args[0] & 1024 ) != 0 && CUR.subpixel_positioned )
+            K |= 1 << 17;
+        }
+      }
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
     args[0] = K;
   }
 
@@ -7509,6 +8156,15 @@
     cur = *exc;
 #endif
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    if ( CUR.ignore_x_mode )
+    {
+      /* ensure some variables are set for this run */
+      CUR.iup_called        = FALSE;
+      CUR.in_delta_function = FALSE;
+    }
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
     /* set CVT functions */
     CUR.tt_metrics.ratio = 0;
     if ( CUR.metrics.x_ppem != CUR.metrics.y_ppem )
@@ -7780,7 +8436,13 @@
           break;
 
         case 0x2B:  /* CALL */
-          Ins_CALL( EXEC_ARG_ args );
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+        if ( !CUR.ignore_x_mode                                         ||
+             !CUR.iup_called                                            ||
+             ( CUR.iup_called                                         &&
+             !( CUR.sph_tweak_flags & SPH_TWEAK_NO_CALL_AFTER_IUP ) ) )
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+            Ins_CALL( EXEC_ARG_ args );
           break;
 
         case 0x2C:  /* FDEF */
@@ -7799,6 +8461,9 @@
 
         case 0x30:  /* IUP */
         case 0x31:  /* IUP */
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+          if ( CUR.ignore_x_mode ) CUR.iup_called = TRUE;
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
           Ins_IUP( EXEC_ARG_ args );
           break;
 
@@ -7958,6 +8623,12 @@
           break;
 
         case 0x5D:  /* DELTAP1 */
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+        if ( !CUR.ignore_x_mode                                         ||
+             !CUR.iup_called                                            ||
+             ( CUR.iup_called                                         &&
+             !( CUR.sph_tweak_flags & SPH_TWEAK_NO_DELTAP_AFTER_IUP ) ) )
+#endif  /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
           Ins_DELTAP( EXEC_ARG_ args );
           break;
 
diff -Nur freetype-orig/src/truetype/ttinterp.h freetype-subpixel/src/truetype/ttinterp.h
--- freetype-orig/src/truetype/ttinterp.h	2012-06-14 00:35:58.000000000 -0500
+++ freetype-subpixel/src/truetype/ttinterp.h	2012-06-16 10:31:58.279833085 -0500
@@ -68,7 +68,8 @@
   /* Rounding function */
   typedef FT_F26Dot6
   (*TT_Round_Func)( EXEC_OP_ FT_F26Dot6  distance,
-                             FT_F26Dot6  compensation );
+                             FT_F26Dot6  compensation,
+                             FT_Int      resolution );
 
   /* Point displacement along the freedom vector routine */
   typedef void
@@ -107,6 +108,44 @@
   } TT_CallRec, *TT_CallStack;
 
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This structure defines a rule used to tweak subpixel hinting for      */
+  /* various fonts.  "", 0, "", NULL value indicates to match any value.   */
+  /*                                                                       */
+
+  typedef struct  SPH_TweakRule_
+  {
+    const char  family[32];
+    const int   ppem;
+    const char  style[32];
+    const FT_ULong  glyph;
+
+  } SPH_TweakRule;
+
+
+  typedef struct  SPH_ScaleRule_
+  {
+    const char  family[32];
+    const int   ppem;
+    const char  style[32];
+    const FT_ULong  glyph;
+    const float scale;
+  } SPH_ScaleRule;
+
+#define MAX_CLASS_MEMBERS 100
+
+  typedef struct  Font_Class_
+  {
+    const char  name[32];
+    const char  member[MAX_CLASS_MEMBERS][32];
+  } Font_Class;
+
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
+
   /*************************************************************************/
   /*                                                                       */
   /* The main structure for the interpreter which collects all necessary   */
@@ -218,6 +257,37 @@
 
     FT_Bool            grayscale;      /* are we hinting for grayscale? */
 
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+    TT_Round_Func      func_round_sphn;   /* subpixel rounding function */
+
+    FT_Bool            grayscale_hinting; /* Using grayscale hinting?      */
+    FT_Bool            subpixel_hinting;  /* Using subpixel hinting?       */
+    FT_Bool            native_hinting;    /* Using native hinting?         */
+    FT_Bool            ignore_x_mode;     /* Standard rendering mode for   */
+                                          /* subpixel hinting. On if gray  */
+                                          /* or subpixel hinting is on )   */
+    FT_Bool            compatibility_mode;/* Additional exceptions to      */
+                                          /* native TT rules for legacy    */
+                                          /* fonts. Implies ignore_x_mode. */
+
+    /* The following 3 aren't fully implemented but here for MS rasterizer */
+    /*   compatibility. */
+    FT_Bool            compatible_widths;    /* compatible widths?     */
+    FT_Bool            symmetrical_smoothing;/* symmetrical_smoothing? */
+    FT_Bool            bgr;                  /* bgr instead of rgb?    */
+    FT_Bool            subpixel_positioned;  /* MS DW subpixel positioned  */
+
+    FT_Int             rasterizer_version;   /* MS rasterizer version  */
+
+    FT_Bool            iup_called;           /* IUP called for glyph?  */
+    FT_Bool            in_delta_function;    /* inside an inline delta func? */
+
+    FT_ULong           sph_tweak_flags;      /* flags to control hint tweaks */
+
+    FT_Int             num_delta_funcs;
+    FT_ULong           inline_delta_funcs[5];
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
   } TT_ExecContextRec;
 
 
diff -Nur freetype-orig/src/truetype/ttobjs.h freetype-subpixel/src/truetype/ttobjs.h
--- freetype-orig/src/truetype/ttobjs.h	2012-06-14 00:35:58.000000000 -0500
+++ freetype-subpixel/src/truetype/ttobjs.h	2012-06-15 07:31:12.163985155 -0500
@@ -178,6 +178,7 @@
     FT_Long  end;        /* where does it end?                 */
     FT_UInt  opc;        /* function #, or instruction code    */
     FT_Bool  active;     /* is it active?                      */
+    FT_Bool  inline_delta; /* is function that defines inline delta? */
 
   } TT_DefRecord, *TT_DefArray;
 
@@ -190,7 +191,7 @@
   {
     FT_Fixed    xx, xy;     /* transformation matrix coefficients */
     FT_Fixed    yx, yy;
-    FT_F26Dot6  ox, oy;     /* offsets        */
+    FT_F26Dot6  ox, oy;     /* offsets                            */
 
   } TT_Transform;
 
diff -Nur freetype-orig/src/truetype/ttsubpix.c freetype-subpixel/src/truetype/ttsubpix.c
--- freetype-orig/src/truetype/ttsubpix.c	1969-12-31 18:00:00.000000000 -0600
+++ freetype-subpixel/src/truetype/ttsubpix.c	2012-06-16 10:32:09.670447034 -0500
@@ -0,0 +1,261 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ttsubpix.c                                                             */
+/*                                                                         */
+/*    TrueType Subpixel Hinting.                                           */
+/*                                                                         */
+/*  Copyright 2010-2011 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+#include <ft2build.h>
+#include FT_INTERNAL_DEBUG_H
+#include FT_INTERNAL_CALC_H
+#include FT_INTERNAL_STREAM_H
+#include FT_INTERNAL_SFNT_H
+#include FT_TRUETYPE_TAGS_H
+#include FT_OUTLINE_H
+
+#include "ttsubpix.h"
+
+
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+
+  FT_LOCAL_DEF( FT_Bool )
+  is_member_of_family_class( const FT_String*      detected_font_name,
+                             const FT_String*      rule_font_name )
+  {
+    FT_UInt  i, j;
+
+    /* If font name matches rule family */
+    if ( strcmp( detected_font_name, rule_font_name ) == 0 ) return TRUE;
+
+    /* If font name is a wildcard "" */
+    if ( strcmp( rule_font_name, "" ) == 0 ) return TRUE;
+
+    /* If font name is contained in a class list */
+    for ( i = 0; i < FAMILY_CLASS_RULES_SIZE; i++ )
+    {
+      if ( strcmp( FAMILY_CLASS_Rules[i].name, rule_font_name ) == 0 )
+      {
+        for ( j = 0; j < MAX_CLASS_MEMBERS; j++ )
+        {
+          if ( strcmp( FAMILY_CLASS_Rules[i].member[j], "" ) == 0 )
+            continue;
+          if ( strcmp( FAMILY_CLASS_Rules[i].member[j], detected_font_name ) == 0 )
+            return TRUE;
+        }
+      }
+    }
+    return FALSE;
+  }
+
+
+  FT_LOCAL_DEF( FT_Bool )
+  is_member_of_style_class( const FT_String*      detected_font_style,
+                            const FT_String*      rule_font_style )
+  {
+    FT_UInt  i, j;
+
+    /* If font style matches rule style */
+    if ( strcmp( detected_font_style, rule_font_style ) == 0 ) return TRUE;
+
+    /* If font style is a wildcard "" */
+    if ( strcmp( rule_font_style, "" ) == 0 ) return TRUE;
+
+    /* If font style is contained in a class list */
+    for ( i = 0; i < STYLE_CLASS_RULES_SIZE; i++ )
+    {
+      if ( strcmp( STYLE_CLASS_Rules[i].name, rule_font_style ) == 0 )
+      {
+        for ( j = 0; j < MAX_CLASS_MEMBERS; j++ )
+        {
+          if ( strcmp( STYLE_CLASS_Rules[i].member[j], "" ) == 0 )
+            continue;
+          if ( strcmp( STYLE_CLASS_Rules[i].member[j], detected_font_style ) == 0 )
+            return TRUE;
+        }
+      }
+    }
+    return FALSE;
+  }
+
+
+  FT_LOCAL_DEF( FT_Bool )
+  sph_test_tweak( TT_Face         face,
+                  FT_String*      family,
+                  int             ppem,
+                  FT_String*      style,
+                  FT_UInt         glyph_index,
+                  SPH_TweakRule*  rule,
+                  FT_UInt         num_rules )
+  {
+    FT_UInt  i;
+
+
+    /* rule checks may be able to be optimized further */
+    for ( i = 0; i < num_rules; i++ )
+    {
+      if ( family                                    &&
+           ( is_member_of_family_class ( family, rule[i].family ) ) )
+        if ( rule[i].ppem == 0    ||
+             rule[i].ppem == ppem )
+          if ( style                                 &&
+               is_member_of_style_class ( style, rule[i].style ) )
+            if ( rule[i].glyph == 0                                ||
+                 FT_Get_Char_Index( (FT_Face)face,
+                                    rule[i].glyph ) == glyph_index )
+        return TRUE;
+    }
+    return FALSE;
+  }
+
+
+  FT_LOCAL_DEF( float )
+  scale_test_tweak( TT_Face         face,
+                  FT_String*      family,
+                  int             ppem,
+                  FT_String*      style,
+                  FT_UInt         glyph_index,
+                  SPH_ScaleRule*  rule,
+                  FT_UInt         num_rules )
+  {
+    FT_UInt  i;
+
+
+    /* rule checks may be able to be optimized further */
+    for ( i = 0; i < num_rules; i++ )
+    {
+      if ( family                                    &&
+           ( is_member_of_family_class ( family, rule[i].family ) ) )
+        if ( rule[i].ppem == 0    ||
+             rule[i].ppem == ppem )
+          if ( style                                 &&
+                 is_member_of_style_class( style, rule[i].style ) )
+            if ( rule[i].glyph == 0                   ||
+                 FT_Get_Char_Index( (FT_Face)face,
+                                    rule[i].glyph ) == glyph_index )
+        return rule[i].scale;
+    }
+    return 1.0;
+  }
+
+#define TWEAK_RULES( x )                                       \
+  if ( sph_test_tweak( face, family, ppem, style, glyph_index, \
+                       x##_Rules, x##_RULES_SIZE ) )           \
+    loader->exec->sph_tweak_flags |= SPH_TWEAK_##x;
+
+#define TWEAK_RULES_EXCEPTIONS( x )                                        \
+  if ( sph_test_tweak( face, family, ppem, style, glyph_index,             \
+                       x##_Rules_Exceptions, x##_RULES_EXCEPTIONS_SIZE ) ) \
+    loader->exec->sph_tweak_flags &= ~SPH_TWEAK_##x;
+
+  FT_LOCAL_DEF( void )
+  sph_set_tweaks( TT_Loader  loader,
+                  FT_UInt    glyph_index )
+  {
+    TT_Face     face   = (TT_Face)loader->face;
+    FT_String*  family = face->root.family_name;
+    int         ppem   = loader->size->metrics.x_ppem;
+    FT_String*  style  = face->root.style_name;
+
+    /* Don't apply rules if style isn't set */
+    if ( !face->root.style_name ) return;
+
+#ifdef SPH_DEBUG_MORE_VERBOSE
+    printf( "%s,%d,%s,%c=%d ", family, ppem, style, glyph_index, glyph_index );
+#endif
+
+    TWEAK_RULES( PIXEL_HINTING );
+
+    if ( loader->exec->sph_tweak_flags & SPH_TWEAK_PIXEL_HINTING )
+    {
+      loader->exec->ignore_x_mode = FALSE;
+      return;
+    }
+
+    TWEAK_RULES( ALLOW_X_DMOVE );
+    TWEAK_RULES( ALLOW_X_DMOVEX );
+    TWEAK_RULES( ALLOW_X_MOVE_ZP2 );
+    TWEAK_RULES( ALWAYS_DO_DELTAP );
+    TWEAK_RULES( ALWAYS_SKIP_DELTAP );
+    TWEAK_RULES( DEEMBOLDEN );
+    TWEAK_RULES( DELTAP_SKIP_EXAGGERATED_VALUES );
+    TWEAK_RULES( DO_SHPIX );
+    TWEAK_RULES( EMBOLDEN );
+    TWEAK_RULES( MIAP_HACK );
+    TWEAK_RULES( NORMAL_ROUND );
+    TWEAK_RULES( NO_ALIGNRP_AFTER_IUP );
+    TWEAK_RULES( NO_CALL_AFTER_IUP );
+    TWEAK_RULES( NO_DELTAP_AFTER_IUP );
+    TWEAK_RULES( RASTERIZER_35 );
+    TWEAK_RULES( SKIP_INLINE_DELTAS );
+    TWEAK_RULES( SKIP_IUP );
+    TWEAK_RULES( MIRP_CVT_ZERO );
+
+    TWEAK_RULES( SKIP_OFFPIXEL_Y_MOVES );
+    TWEAK_RULES_EXCEPTIONS( SKIP_OFFPIXEL_Y_MOVES );
+
+    TWEAK_RULES( SKIP_NONPIXEL_Y_MOVES );
+    TWEAK_RULES_EXCEPTIONS( SKIP_NONPIXEL_Y_MOVES );
+
+    TWEAK_RULES( ROUND_NONPIXEL_Y_MOVES );
+    TWEAK_RULES_EXCEPTIONS( ROUND_NONPIXEL_Y_MOVES );
+
+    if ( loader->exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
+    {
+      if ( loader->exec->rasterizer_version != 35 )
+      {
+        loader->exec->rasterizer_version = 35;
+        /* must re-execute fpgm */
+        loader->exec->size->cvt_ready      = FALSE;
+        tt_size_ready_bytecode( loader->exec->size,
+                                FT_BOOL( loader->load_flags & FT_LOAD_PEDANTIC ) );
+      }
+    }
+    else
+    {
+      if ( loader->exec->rasterizer_version == 35 )
+      {
+        loader->exec->rasterizer_version = 37;
+        /* must re-execute fpgm */
+        loader->exec->size->cvt_ready      = FALSE;
+        tt_size_ready_bytecode( loader->exec->size,
+                                FT_BOOL( loader->load_flags & FT_LOAD_PEDANTIC ) );
+      }
+    }
+
+    if ( IS_HINTED( loader->load_flags ) )
+    {
+      TWEAK_RULES( TIMES_NEW_ROMAN_HACK );
+      TWEAK_RULES( COURIER_NEW_2_HACK );
+    }
+
+    if ( sph_test_tweak( face, family, ppem, style, glyph_index,
+           COMPATIBILITY_MODE_Rules, COMPATIBILITY_MODE_RULES_SIZE ) )
+    {
+        loader->exec->compatibility_mode |= TRUE;
+        loader->exec->ignore_x_mode |= TRUE;
+    }
+    else
+      loader->exec->compatibility_mode &= FALSE;
+
+    if ( IS_HINTED( loader->load_flags ) )
+    {
+      if ( sph_test_tweak( face, family, ppem, style, glyph_index,
+           COMPATIBLE_WIDTHS_Rules, COMPATIBLE_WIDTHS_RULES_SIZE ) )
+        loader->exec->compatible_widths |= TRUE;
+    }
+  }
+
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
+
+/* END */
diff -Nur freetype-orig/src/truetype/ttsubpix.h freetype-subpixel/src/truetype/ttsubpix.h
--- freetype-orig/src/truetype/ttsubpix.h	1969-12-31 18:00:00.000000000 -0600
+++ freetype-subpixel/src/truetype/ttsubpix.h	2012-06-16 10:30:26.121956142 -0500
@@ -0,0 +1,778 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ttsubpix.h                                                             */
+/*                                                                         */
+/*    TrueType Subpixel Hinting.                                           */
+/*                                                                         */
+/*  Copyright 2010-2011 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+#ifndef __TTSUBPIX_H__
+#define __TTSUBPIX_H__
+
+#include <ft2build.h>
+#include "ttobjs.h"
+#include "ttinterp.h"
+
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Tweak flags that are set for each glyph by the below rules            */
+  /*                                                                       */
+  /*                                                                       */
+#define SPH_TWEAK_ALLOW_X_DMOVE                    0x0000001
+#define SPH_TWEAK_ALLOW_X_DMOVEX                   0x0000002
+#define SPH_TWEAK_ALLOW_X_MOVE_ZP2                 0x0000004
+#define SPH_TWEAK_ALWAYS_DO_DELTAP                 0x0000008
+#define SPH_TWEAK_ALWAYS_SKIP_DELTAP               0x0000010
+#define SPH_TWEAK_COURIER_NEW_2_HACK               0x0000020
+#define SPH_TWEAK_DEEMBOLDEN                       0x0000040
+#define SPH_TWEAK_DELTAP_SKIP_EXAGGERATED_VALUES   0x0000080
+#define SPH_TWEAK_DO_SHPIX                         0x0000100
+#define SPH_TWEAK_EMBOLDEN                         0x0000200
+#define SPH_TWEAK_MIAP_HACK                        0x0000400
+#define SPH_TWEAK_NORMAL_ROUND                     0x0000800
+#define SPH_TWEAK_NO_ALIGNRP_AFTER_IUP             0x0001000
+#define SPH_TWEAK_NO_CALL_AFTER_IUP                0x0002000
+#define SPH_TWEAK_NO_DELTAP_AFTER_IUP              0x0004000
+#define SPH_TWEAK_PIXEL_HINTING                    0x0008000
+#define SPH_TWEAK_RASTERIZER_35                    0x0010000
+#define SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES           0x0020000
+#define SPH_TWEAK_SKIP_INLINE_DELTAS               0x0040000
+#define SPH_TWEAK_SKIP_IUP                         0x0080000
+#define SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES            0x0100000
+#define SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES            0x0200000
+#define SPH_TWEAK_TIMES_NEW_ROMAN_HACK             0x0400000
+#define SPH_TWEAK_MIRP_CVT_ZERO                    0x0800000
+
+
+  FT_LOCAL( FT_Bool )
+  sph_test_tweak( TT_Face         face,
+                  FT_String*      family,
+                  int             ppem,
+                  FT_String*      style,
+                  FT_UInt         glyph_index,
+                  SPH_TweakRule*  rule,
+                  FT_UInt         num_rules );
+
+  FT_LOCAL_DEF( float )
+  scale_test_tweak( TT_Face         face,
+                  FT_String*      family,
+                  int             ppem,
+                  FT_String*      style,
+                  FT_UInt         glyph_index,
+                  SPH_ScaleRule*  rule,
+                  FT_UInt         num_rules );
+
+  FT_LOCAL( void )
+  sph_set_tweaks( TT_Loader  loader,
+                  FT_UInt    glyph_index );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* These rules affect how the TT Interpreter does hinting, with the      */
+  /* goal of doing subpixel hinting by (in general) ignoring x moves.      */
+  /* Some of these rules are fixes that go above and beyond the            */
+  /* stated techniques in the MS whitepaper on Cleartype, due to           */
+  /* artifacts in many glyphs.  So, these rules make some glyphs render    */
+  /* better than they do in the MS rasterizer.                             */
+  /*                                                                       */
+  /* "" string or 0 int/char indicates to apply to all glyphs.             */
+  /* "-" used as dummy placeholders, but any non-matching string works.    */
+  /*                                                                       */
+  /* Some of this could arguably be implemented in fontconfig, however:    */
+  /*                                                                       */
+  /*  - Fontconfig can't set things on a glyph-by-glyph basis.             */
+  /*  - The tweaks that happen here are very low-level, from an average    */
+  /*    user's point of view and are best implemented in the hinter        */
+  /*                                                                       */
+  /* The goal is to make the subpixel hinting techniques as generalized    */
+  /* as possible across all fonts to prevent the need for extra rules such */
+  /* as these.                                                             */
+  /*                                                                       */
+  /* The rule structure is designed so that entirely new rules can easily  */
+  /* be added when a new compatibility feature is discovered.              */
+  /*                                                                       */
+  /* The rule structures could also use some enhancement to handle ranges. */
+  /*                                                                       */
+  /*     ****************** WORK IN PROGRESS *******************           */
+  /*                                                                       */
+
+#define SPH_OPTION_BITMAP_WIDTHS           FALSE
+#define SPH_OPTION_SET_SUBPIXEL            TRUE
+#define SPH_OPTION_SET_GRAYSCALE           FALSE
+#define SPH_OPTION_SET_COMPATIBLE_WIDTHS   FALSE
+#define SPH_OPTION_SET_RASTERIZER_VERSION  37
+#define SPH_OPTION_GRIDLINES_PER_PIXEL_X   64
+#define SPH_OPTION_GRIDLINES_PER_PIXEL_Y   1
+
+#define MAX_CLASS_MEMBERS                  100
+
+/* Define this to force natural (i.e. not bitmap-compatible) widths.       */
+/* The default leans strongly towards natural widths except for a few      */
+/* legacy fonts where a selective combination produces nicer results.      */
+/* #define FORCE_NATURAL_WIDTHS   */
+
+
+  /* These are "classes" of fonts that can be grouped together and used in */
+  /* rules below. A blank entry "" is required at the end of these!        */
+#define FAMILY_CLASS_RULES_SIZE 7
+  Font_Class FAMILY_CLASS_Rules
+                   [FAMILY_CLASS_RULES_SIZE] =
+                 {
+                   { "MS Legacy Fonts", { "Aharoni",
+                                              "Andale Mono",
+                                              "Andalus",
+                                              "Angsana New",
+                                              "AngsanaUPC",
+                                              "Arabic Transparent",
+                                              "Arial Black",
+                                              "Arial Narrow",
+                                              "Arial Unicode MS",
+                                              "Arial",
+                                              "Batang",
+                                              "Browallia New",
+                                              "BrowalliaUPC",
+                                              "Comic Sans MS",
+                                              "Cordia New",
+                                              "CordiaUPC",
+                                              "Courier New",
+                                              "DFKai-SB",
+                                              "David Transparent",
+                                              "David",
+                                              "DilleniaUPC",
+                                              "Estrangelo Edessa",
+                                              "EucrosiaUPC",
+                                              "FangSong_GB2312",
+                                              "Fixed Miriam Transparent",
+                                              "FrankRuehl",
+                                              "Franklin Gothic Medium",
+                                              "FreesiaUPC",
+                                              "Garamond",
+                                              "Gautami",
+                                              "Georgia",
+                                              "Gulim",
+                                              "Impact",
+                                              "IrisUPC",
+                                              "JasmineUPC",
+                                              "KaiTi_GB2312",
+                                              "KodchiangUPC",
+                                              "Latha",
+                                              "Levenim MT",
+                                              "LilyUPC",
+                                              "Lucida Console",
+                                              "Lucida Sans Unicode",
+                                              "MS Gothic",
+                                              "MS Mincho",
+                                              "MV Boli",
+                                              "Mangal",
+                                              "Marlett",
+                                              "Microsoft Sans Serif",
+                                              "Mingliu",
+                                              "Miriam Fixed",
+                                              "Miriam Transparent",
+                                              "Miriam",
+                                              "Narkisim",
+                                              "Palatino Linotype",
+                                              "Raavi",
+                                              "Rod Transparent",
+                                              "Rod",
+                                              "Shruti",
+                                              "SimHei",
+                                              "Simplified Arabic Fixed",
+                                              "Simplified Arabic",
+                                              "Simsun",
+                                              "Sylfaen",
+                                              "Symbol",
+                                              "Tahoma",
+                                              "Times New Roman",
+                                              "Traditional Arabic",
+                                              "Trebuchet MS",
+                                              "Tunga",
+                                              "Verdana",
+                                              "Webdings",
+                                              "Wingdings", "", }, },
+                   { "Core MS Legacy Fonts", { "Arial Black",
+                                              "Arial Narrow",
+                                              "Arial Unicode MS",
+                                              "Arial",
+                                              "Comic Sans MS",
+                                              "Courier New",
+                                              "Garamond",
+                                              "Georgia",
+                                              "Impact",
+                                              "Lucida Console",
+                                              "Lucida Sans Unicode",
+                                              "Microsoft Sans Serif",
+                                              "Palatino Linotype",
+                                              "Tahoma",
+                                              "Times New Roman",
+                                              "Trebuchet MS",
+                                              "Verdana", "", }, },
+                   { "Apple Legacy Fonts", { "Geneva",
+                                              "Times",
+                                              "Monaco",
+                                              "Century",
+                                              "Chalkboard",
+                                              "Lobster",
+                                              "Century Gothic",
+                                              "Optima",
+                                              "Lucida Grande",
+                                              "Gill Sans",
+                                              "Baskerville",
+                                              "Helvetica",
+                                              "Helvetica Neue", "", }, },
+                   { "Legacy Sans Fonts", { "Andale Mono",
+                                              "Arial Unicode MS",
+                                              "Arial",
+                                              "Century Gothic",
+                                              "Comic Sans MS",
+                                              "Franklin Gothic Medium",
+                                              "Geneva",
+                                              "Lucida Console",
+                                              "Lucida Grande",
+                                              "Lucida Sans Unicode",
+                                              "Microsoft Sans Serif",
+                                              "Monaco",
+                                              "Tahoma",
+                                              "Trebuchet MS",
+                                              "Verdana", "", }, },
+                   { "Misc Legacy Fonts",  { "Dark Courier", "", }, },
+                   { "Verdana Clones",   { "DejaVu Sans",
+                                              "Bitstream Vera Sans", "", }, },
+                   { "Verdana and Clones", { "DejaVu Sans",
+                                              "Bitstream Vera Sans",
+                                              "Verdana", "", }, },
+};
+
+
+  /* Define "classes" of styles that can be grouped together and used in   */
+  /* rules below. A blank entry "" is required at the end of these!        */
+#define STYLE_CLASS_RULES_SIZE 5
+  Font_Class STYLE_CLASS_Rules
+                   [STYLE_CLASS_RULES_SIZE] =
+                 {
+                   { "Regular Class", { "Regular",
+                                              "Book",
+                                              "Medium",
+                                              "Roman",
+                                              "Normal", "", }, },
+                   { "Regular/Italic Class", { "Regular",
+                                              "Book",
+                                              "Medium",
+                                              "Italic",
+                                              "Oblique",
+                                              "Roman",
+                                              "Normal", "", }, },
+                   { "Bold/BoldItalic Class", { "Bold",
+                                              "Bold Italic",
+                                              "Black", "", }, },
+                   { "Bold/Italic/BoldItalic Class", { "Bold",
+                                              "Bold Italic",
+                                              "Black",
+                                              "Italic",
+                                              "Oblique", "", }, },
+                   { "Regular/Bold Class", { "Regular",
+                                              "Book",
+                                              "Medium",
+                                              "Normal",
+                                              "Roman",
+                                              "Bold",
+                                              "Black", "", }, },
+                 };
+
+
+
+  /* Special fixes for known legacy fonts                                  */
+  /* This is the primary workhorse rule for legacy fonts                   */
+#define COMPATIBILITY_MODE_RULES_SIZE  4
+  SPH_TweakRule  COMPATIBILITY_MODE_Rules
+                   [COMPATIBILITY_MODE_RULES_SIZE] =
+                 {
+                   { "MS Legacy Fonts", 0, "", 0 },
+                   { "Apple Legacy Fonts", 0, "", 0 },
+                   { "Misc Legacy Fonts", 0, "", 0 },
+                   { "Verdana Clones", 0, "", 0 },
+                 };
+
+
+  /* Don't do subpixel (ignore_x_mode) hinting; do normal hinting          */
+#define PIXEL_HINTING_RULES_SIZE  4
+  SPH_TweakRule  PIXEL_HINTING_Rules
+                   [PIXEL_HINTING_RULES_SIZE] =
+                 {
+                   /* These characters are almost always safe */
+                   { "", 0, "", '<' },
+                   { "", 0, "", '>' },
+                   /* Fixes the vanishing stem */
+                   { "Times New Roman", 0, "Bold", 'A' },
+                   { "Times New Roman", 0, "Bold", 'V' },
+                 };
+
+
+  /* According to Greg Hitchcock and the MS whitepaper, this should work   */
+  /* on all legacy MS fonts, but creates artifacts with some. Only using   */
+  /* where absolutely necessary.                                           */
+#define SKIP_INLINE_DELTAS_RULES_SIZE  1
+  SPH_TweakRule  SKIP_INLINE_DELTAS_Rules
+                   [SKIP_INLINE_DELTAS_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+
+  /* Subpixel hinting ignores SHPIX rules on X.  Force SHPIX for these.    */
+#define DO_SHPIX_RULES_SIZE  1
+  SPH_TweakRule  DO_SHPIX_Rules
+                   [DO_SHPIX_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+
+  /* Skip Y moves that start with a point that is not on a Y pixel         */
+  /* boundary and don't move that point to a Y pixel boundary.             */
+#define SKIP_NONPIXEL_Y_MOVES_RULES_SIZE  8
+  SPH_TweakRule  SKIP_NONPIXEL_Y_MOVES_Rules
+                   [SKIP_NONPIXEL_Y_MOVES_RULES_SIZE] =
+                 {
+                   /* fix vwxyz thinness*/
+                   { "Consolas", 0, "Regular", 0 },
+                   /* fix tiny gap at top of m */
+                   { "Arial", 0, "Regular", 'm' },
+                   /* Fix thin middle stems */
+                   { "Core MS Legacy Fonts", 0, "Regular/Bold Class", 'N' },
+                   { "Lucida Grande", 0, "", 'N' },
+                   { "Legacy Sans Fonts", 0, "", L'' },
+                   { "Verdana Clones", 0, "",'N' },
+                   { "Ubuntu", 0, "Regular Class", 'N' },
+                   /* Fix misshapen x */
+                   { "Verdana", 0, "Bold", 'x' },
+                 };
+
+#define SKIP_NONPIXEL_Y_MOVES_RULES_EXCEPTIONS_SIZE  4
+  SPH_TweakRule  SKIP_NONPIXEL_Y_MOVES_Rules_Exceptions
+                   [SKIP_NONPIXEL_Y_MOVES_RULES_EXCEPTIONS_SIZE] =
+                 {
+                   { "Tahoma", 0, "", 'N' },
+                   { "Comic Sans MS", 0, "", 'N' },
+                   { "Verdana", 0, "Regular/Bold Class", 'N' },
+                   { "Verdana", 11, "Bold", 'x' },
+                 };
+
+
+
+  /* Skip Y moves that move a point off a Y pixel boundary                 */
+  /* This fixes Tahoma, Trebuchet oddities and some issues with `$'        */
+#define SKIP_OFFPIXEL_Y_MOVES_RULES_SIZE  5
+  SPH_TweakRule  SKIP_OFFPIXEL_Y_MOVES_Rules
+                   [SKIP_OFFPIXEL_Y_MOVES_RULES_SIZE] =
+                 {
+                   { "MS Legacy Fonts", 0, "", 0 },
+                   { "Apple Legacy Fonts", 0, "", 0 },
+                   { "Misc Legacy Fonts", 0, "", 0 },
+                   { "Ubuntu", 0, "Regular Class", 0 },
+                   { "Verdana Clones", 0, "", 0 },
+                 };
+
+
+#define SKIP_OFFPIXEL_Y_MOVES_RULES_EXCEPTIONS_SIZE  1
+  SPH_TweakRule  SKIP_OFFPIXEL_Y_MOVES_Rules_Exceptions
+                   [SKIP_OFFPIXEL_Y_MOVES_RULES_EXCEPTIONS_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+
+  /* Round moves that don't move a point to a Y pixel boundary             */
+#define ROUND_NONPIXEL_Y_MOVES_RULES_SIZE  3
+  SPH_TweakRule  ROUND_NONPIXEL_Y_MOVES_Rules
+                   [ROUND_NONPIXEL_Y_MOVES_RULES_SIZE] =
+                 {
+                   /* Droid font instructions don't snap Y to pixels */
+                   { "Droid Sans", 0, "Regular/Italic Class", 0 },
+                   { "Droid Sans Mono", 0, "", 0 },
+                   { "Ubuntu", 0, "", 0 },
+                 };
+
+#define ROUND_NONPIXEL_Y_MOVES_RULES_EXCEPTIONS_SIZE  3
+  SPH_TweakRule  ROUND_NONPIXEL_Y_MOVES_Rules_Exceptions
+                   [ROUND_NONPIXEL_Y_MOVES_RULES_EXCEPTIONS_SIZE] =
+                 {
+                   { "Droid Sans", 12, "Bold", 0 },
+                   { "Droid Sans", 13, "Bold", 0 },
+                   { "Droid Sans", 16, "Bold", 0 },
+                 };
+
+  /* Allow a Direct_Move_X along X freedom vector if matched               */
+#define ALLOW_X_DMOVEX_RULES_SIZE  2
+  SPH_TweakRule  ALLOW_X_DMOVEX_Rules
+                   [ALLOW_X_DMOVEX_RULES_SIZE] =
+                 {
+                   /* Creates a more consistent appearance for these */
+                   { "Arial", 13, "Regular", 'e' },
+                   { "Arial", 13, "Regular", 'o' },
+                 };
+
+  /* Allow a Direct_Move along X freedom vector if matched                 */
+#define ALLOW_X_DMOVE_RULES_SIZE  3
+  SPH_TweakRule  ALLOW_X_DMOVE_Rules
+                   [ALLOW_X_DMOVE_RULES_SIZE] =
+                 {
+                   /* Creates a more consistent appearance for these */
+                   { "Arial", 13, "Regular", 'e' },
+                   { "Arial", 13, "Regular", 'o' },
+                   /* Fixes vanishing diagonal in 4 */
+                   { "Verdana", 0, "Regular", '4' },
+                 };
+
+  /* Allow a ZP2 move along freedom vector if matched;                     */
+  /* This is called from SHP, SHPIX, SHC, SHZ                              */
+#define ALLOW_X_MOVE_ZP2_RULES_SIZE  1
+  SPH_TweakRule  ALLOW_X_MOVE_ZP2_Rules
+                   [ALLOW_X_MOVE_ZP2_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+  /* Return MS rasterizer version 35 if matched                            */
+#define RASTERIZER_35_RULES_SIZE 8
+  SPH_TweakRule  RASTERIZER_35_Rules
+                   [RASTERIZER_35_RULES_SIZE] =
+                 {
+                   /* This seems to be the only way to make these look good */
+                   { "Times New Roman", 0, "Regular", 'i' },
+                   { "Times New Roman", 0, "Regular", 'j' },
+                   { "Times New Roman", 0, "Regular", 'm' },
+                   { "Times New Roman", 0, "Regular", 'r' },
+                   { "Times New Roman", 0, "Regular", 'a' },
+                   { "Times New Roman", 0, "Regular", 'n' },
+                   { "Times New Roman", 0, "Regular", 'p' },
+                   { "Times", 0, "", 0 },
+                 };
+
+  /* Don't round to the subpixel grid. Round to pixel grid.                */
+#define NORMAL_ROUND_RULES_SIZE  2
+  SPH_TweakRule  NORMAL_ROUND_Rules
+                   [NORMAL_ROUND_RULES_SIZE] =
+                 {
+                   /* Fix point "explosions" */
+                   { "Courier New", 0, "", 0 },
+                   { "Verdana", 10, "Regular", '4' },
+                 };
+
+  /* Skip IUP instructions if matched                                      */
+#define SKIP_IUP_RULES_SIZE  1
+  SPH_TweakRule  SKIP_IUP_Rules
+                   [SKIP_IUP_RULES_SIZE] =
+                 {
+                   { "Arial", 13, "Regular", 'a' },
+                 };
+
+  /* Skip MIAP Twilight hack if matched                                    */
+#define MIAP_HACK_RULES_SIZE  1
+  SPH_TweakRule  MIAP_HACK_Rules
+                   [MIAP_HACK_RULES_SIZE] =
+                 {
+                   { "Geneva", 12, "", 0 },
+                 };
+
+  /* Skip DELTAP instructions if matched                                   */
+#define ALWAYS_SKIP_DELTAP_RULES_SIZE  13
+  SPH_TweakRule  ALWAYS_SKIP_DELTAP_Rules
+                   [ALWAYS_SKIP_DELTAP_RULES_SIZE] =
+                 {
+                   { "Georgia", 0, "Regular", 'k' },
+                   /* fixes problems with W M w */
+                   { "Trebuchet MS", 0, "Italic", 0 },
+                   { "Trebuchet MS", 14, "Regular", 'e' },
+                   { "Arial", 11, "Regular", 's' },
+                   { "Verdana", 10, "Regular", 0 },
+                   { "Verdana", 9, "Regular", 0 },
+                   { "Legacy Sans Fonts", 0, "", L'' },
+                   { "Arial", 10, "Regular", '6' },
+                   { "Arial", 0, "Bold/BoldItalic Class", 'a' },
+                    /* Make horizontal stems consistent with the rest */
+                   { "Arial", 24, "Bold", 's' },
+                   { "Arial", 25, "Bold", 's' },
+                   { "Arial", 24, "Bold", 'a' },
+                   { "Arial", 25, "Bold", 'a' },
+                 };
+
+  /* Always do DELTAP instructions if matched                              */
+#define ALWAYS_DO_DELTAP_RULES_SIZE  2
+  SPH_TweakRule  ALWAYS_DO_DELTAP_Rules
+                   [ALWAYS_DO_DELTAP_RULES_SIZE] =
+                 {
+                   { "Verdana Clones", 17, "Regular Class", 'K' },
+                   { "Verdana Clones", 17, "Regular Class", 'k' },
+                 };
+
+  /* Do an extra RTG instruction in DELTAP if matched                      */
+#define DELTAP_RTG_RULES_SIZE  1
+  SPH_TweakRule  DELTAP_RTG_Rules
+                   [DELTAP_RTG_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+  /* Force CVT distance to zero in MIRP                                    */
+#define MIRP_CVT_ZERO_RULES_SIZE  1
+  SPH_TweakRule  MIRP_CVT_ZERO_Rules
+                   [MIRP_CVT_ZERO_RULES_SIZE] =
+                 {
+                   { "Verdana", 0, "Regular", 0 },
+                 };
+
+  /* Skip moves that meet or exceed 1 pixel                                */
+#define DELTAP_SKIP_EXAGGERATED_VALUES_RULES_SIZE  2
+  SPH_TweakRule  DELTAP_SKIP_EXAGGERATED_VALUES_Rules
+                   [DELTAP_SKIP_EXAGGERATED_VALUES_RULES_SIZE] =
+                 {
+                   /* Fix vanishing stems */
+                   { "Ubuntu", 0, "Regular", 'M' },
+                   /* Fix X at larger ppems */
+                   { "Segoe UI", 0, "Light", 0 },
+                 };
+
+  /* Don't allow ALIGNRP after IUP                                         */
+#define NO_ALIGNRP_AFTER_IUP_RULES_SIZE  4
+  SPH_TweakRule  NO_ALIGNRP_AFTER_IUP_Rules
+                   [NO_ALIGNRP_AFTER_IUP_RULES_SIZE] =
+                 {
+                   /* Prevent creation of dents in outline */
+                   { "Courier New", 0, "Bold", 'C' },
+                   { "Courier New", 0, "Bold", 'D' },
+                   { "Courier New", 0, "Bold", 'Q' },
+                   { "Courier New", 0, "Bold", '0' },
+                 };
+
+  /* Don't allow DELTAP after IUP                                          */
+#define NO_DELTAP_AFTER_IUP_RULES_SIZE  2
+  SPH_TweakRule  NO_DELTAP_AFTER_IUP_Rules
+                   [NO_DELTAP_AFTER_IUP_RULES_SIZE] =
+                 {
+                   { "Arial", 0, "Bold", 'N' },
+                   { "Verdana", 0, "Regular", '4' },
+                 };
+
+  /* Don't allow CALL after IUP                                            */
+#define NO_CALL_AFTER_IUP_RULES_SIZE  4
+  SPH_TweakRule  NO_CALL_AFTER_IUP_Rules
+                   [NO_CALL_AFTER_IUP_RULES_SIZE] =
+                 {
+                   /* Prevent creation of dents in outline */
+                   { "Courier New", 0, "Bold", 'O' },
+                   { "Courier New", 0, "Bold", 'Q' },
+                   { "Courier New", 0, "Bold", 'k' },
+                   { "Courier New", 0, "Bold Italic", 'M' },
+                 };
+
+  /* De-embolden these glyphs slightly                                     */
+#define DEEMBOLDEN_RULES_SIZE  9
+  SPH_TweakRule  DEEMBOLDEN_Rules
+                   [DEEMBOLDEN_RULES_SIZE] =
+                 {
+                   { "Courier New", 0, "Bold", 'A' },
+                   { "Courier New", 0, "Bold", 'W' },
+                   { "Courier New", 0, "Bold", 'w' },
+                   { "Courier New", 0, "Bold", 'M' },
+                   { "Courier New", 0, "Bold", 'X' },
+                   { "Courier New", 0, "Bold", 'K' },
+                   { "Courier New", 0, "Bold", 'x' },
+                   { "Courier New", 0, "Bold", 'z' },
+                   { "Courier New", 0, "Bold", 'v' },
+                 };
+
+  /* Embolden these glyphs slightly                                        */
+#define EMBOLDEN_RULES_SIZE  5
+  SPH_TweakRule  EMBOLDEN_Rules
+                   [EMBOLDEN_RULES_SIZE] =
+                 {
+                   { "Courier New", 12, "Italic", 'z' },
+                   { "Courier New", 11, "Italic", 'z' },
+                   { "Courier New", 10, "Italic", 'z' },
+                   { "Courier New", 0, "Regular", 0 },
+                   { "Courier New", 0, "Italic", 0 },
+                 };
+
+  /* Do an extra RDTG instruction in DELTAP if matched                     */
+#define DELTAP_RDTG_RULES_SIZE 1
+  SPH_TweakRule  DELTAP_RDTG_Rules
+                   [DELTAP_RDTG_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+  /* This is a CVT hack that makes thick horizontal stems on 2, 5, 7       */
+  /* similar to Windows XP.                                                */
+#define TIMES_NEW_ROMAN_HACK_RULES_SIZE 12
+  SPH_TweakRule  TIMES_NEW_ROMAN_HACK_Rules
+                   [TIMES_NEW_ROMAN_HACK_RULES_SIZE] =
+                 {
+                   { "Times New Roman", 16, "Italic", '2' },
+                   { "Times New Roman", 16, "Italic", '5' },
+                   { "Times New Roman", 16, "Italic", '7' },
+                   { "Times New Roman", 16, "Regular", '2' },
+                   { "Times New Roman", 16, "Regular", '5' },
+                   { "Times New Roman", 16, "Regular", '7' },
+                   { "Times New Roman", 17, "Italic", '2' },
+                   { "Times New Roman", 17, "Italic", '5' },
+                   { "Times New Roman", 17, "Italic", '7' },
+                   { "Times New Roman", 17, "Regular", '2' },
+                   { "Times New Roman", 17, "Regular", '5' },
+                   { "Times New Roman", 17, "Regular", '7' },
+                 };
+
+
+  /* This fudges distance on 2 to get rid of the vanishing stem issue.     */
+  /* A real solution to this is certainly welcome.                         */
+#define COURIER_NEW_2_HACK_RULES_SIZE 15
+  SPH_TweakRule  COURIER_NEW_2_HACK_Rules
+                   [COURIER_NEW_2_HACK_RULES_SIZE] =
+                 {
+                   { "Courier New", 10, "Regular", '2' },
+                   { "Courier New", 11, "Regular", '2' },
+                   { "Courier New", 12, "Regular", '2' },
+                   { "Courier New", 13, "Regular", '2' },
+                   { "Courier New", 14, "Regular", '2' },
+                   { "Courier New", 15, "Regular", '2' },
+                   { "Courier New", 16, "Regular", '2' },
+                   { "Courier New", 17, "Regular", '2' },
+                   { "Courier New", 18, "Regular", '2' },
+                   { "Courier New", 19, "Regular", '2' },
+                   { "Courier New", 20, "Regular", '2' },
+                   { "Courier New", 21, "Regular", '2' },
+                   { "Courier New", 22, "Regular", '2' },
+                   { "Courier New", 23, "Regular", '2' },
+                   { "Courier New", 24, "Regular", '2' },
+                 };
+
+
+#ifndef FORCE_NATURAL_WIDTHS
+
+  /* Use compatible widths with these glyphs.  Compatible widths is always */
+  /* on when doing B/W TrueType instructing, but is used selectively here, */
+  /* typically on glyphs with 3 or more vertical stems.                    */
+#define COMPATIBLE_WIDTHS_RULES_SIZE 36
+  SPH_TweakRule  COMPATIBLE_WIDTHS_Rules
+                   [COMPATIBLE_WIDTHS_RULES_SIZE] =
+                 {
+                   { "Arial Unicode MS", 12, "Regular Class", 'm' },
+                   { "Arial Unicode MS", 14, "Regular Class", 'm' },
+                   { "Arial", 10, "Regular Class", L'' },
+                   { "Arial", 11, "Regular Class", 'm' },
+                   { "Arial", 12, "Regular Class", 'm' },
+                   { "Arial", 12, "Regular Class", L'' },
+                   { "Arial", 13, "Regular Class", L'' },
+                   { "Arial", 14, "Regular Class", 'm' },
+                   { "Arial", 14, "Regular Class", L'' },
+                   { "Arial", 15, "Regular Class", L'' },
+                   { "Arial", 17, "Regular Class", 'm' },
+                   { "DejaVu Sans", 15, "Regular Class", 0 },
+                   { "Microsoft Sans Serif", 11, "Regular Class", 0 },
+                   { "Microsoft Sans Serif", 12, "Regular Class", 0 },
+                   { "Segoe UI", 11, "Regular Class", 0 },
+                   { "Segoe UI", 12, "Regular Class", 'm' },
+                   { "Segoe UI", 14, "Regular Class", 'm' },
+                   { "Tahoma", 11, "Regular Class", 0 },
+                   { "Times New Roman", 16, "Regular Class", 'c' },
+                   { "Times New Roman", 16, "Regular Class", 'm' },
+                   { "Times New Roman", 16, "Regular Class", 'o' },
+                   { "Times New Roman", 16, "Regular Class", 'w' },
+                   { "Trebuchet MS", 12, "Regular Class", 0 },
+                   { "Trebuchet MS", 14, "Regular Class", 0 },
+                   { "Trebuchet MS", 15, "Regular Class", 0 },
+                   { "Ubuntu", 12, "Regular Class", 'm' },
+                   { "Verdana", 10, "Regular Class", L'' },
+                   { "Verdana", 11, "Regular Class", L'' },
+                   { "Verdana and Clones", 12, "Regular Class", 'm' },
+                   { "Verdana and Clones", 12, "Regular Class", 'l' },
+                   { "Verdana and Clones", 12, "Regular Class", 'i' },
+                   { "Verdana and Clones", 12, "Regular Class", 'j' },
+                   { "Verdana and Clones", 13, "Regular Class", 'l' },
+                   { "Verdana and Clones", 13, "Regular Class", 'i' },
+                   { "Verdana and Clones", 13, "Regular Class", 'j' },
+                   { "Verdana and Clones", 14, "Regular Class", 'm' },
+                 };
+
+
+  /* Scaling slightly in the x-direction prior to hinting results in       */
+  /* more visually pleasing glyphs in certain cases.                       */
+  /* This sometimes needs to be coordinated with compatible width rules.   */
+#define X_SCALING_RULES_SIZE 40
+  SPH_ScaleRule  X_SCALING_Rules
+                   [X_SCALING_RULES_SIZE] =
+                 {
+                   { "DejaVu Sans", 12, "Regular Class", 'm', .95 },
+                   { "Verdana and Clones", 12, "Regular Class", 'a', 1.1 },
+                   { "Arial", 11, "Regular Class", 'm', .975 },
+                   { "Arial", 12, "Regular Class", 'm', 1.05 },
+                   { "Arial", 13, "Regular Class", L'', .95 },
+                   { "Arial", 14, "Regular Class", 'm', .95 },
+                   { "Arial", 15, "Regular Class", L'', .925 },
+                   { "Bitstream Vera Sans", 10, "Regular Class", 0, 1.1 },
+                   { "Bitstream Vera Sans", 12, "Regular Class", 0, 1.05},
+                   { "Bitstream Vera Sans", 16, "Regular Class", 0, 1.05 },
+                   { "Bitstream Vera Sans", 9, "Regular Class", 0, 1.05},
+                   { "DejaVu Sans", 12, "Regular Class", 'l', .975 },
+                   { "DejaVu Sans", 12, "Regular Class", 'i', .975 },
+                   { "DejaVu Sans", 12, "Regular Class", 'j', .975 },
+                   { "DejaVu Sans", 13, "Regular Class", 'l', .95 },
+                   { "DejaVu Sans", 13, "Regular Class", 'i', .95 },
+                   { "DejaVu Sans", 13, "Regular Class", 'j', .95 },
+                   { "DejaVu Sans", 10, "Regular Class", 0, 1.1 },
+                   { "DejaVu Sans", 12, "Regular Class", 0, 1.05 },
+                   { "Georgia", 10, "", 0, 1.05 },
+                   { "Georgia", 11, "", 0, 1.1 },
+                   { "Georgia", 12, "", 0, 1.025 },
+                   { "Georgia", 13, "", 0, 1.05 },
+                   { "Georgia", 16, "", 0, 1.05 },
+                   { "Georgia", 17, "", 0, 1.03 },
+                   { "Liberation Sans", 12, "Regular Class", 'm', 1.1 },
+                   { "Lucida Grande", 11, "Regular Class", 'm', 1.1 },
+                   { "Microsoft Sans Serif", 11, "Regular Class", 'm', .95 },
+                   { "Microsoft Sans Serif", 12, "Regular Class", 'm', 1.05 },
+                   { "Segoe UI", 12, "Regular Class", 'H', 1.05 },
+                   { "Segoe UI", 12, "Regular Class", 'm', 1.05 },
+                   { "Segoe UI", 14, "Regular Class", 'm', 1.05 },
+                   { "Tahoma", 11, "Regular Class", 'm', .975 },
+                   { "Verdana", 10, "Regular Class", 0, 1.1 },
+                   { "Verdana", 12, "Regular Class", 'm', .975 },
+                   { "Verdana", 12, "Regular Class", 0, 1.05 },
+                   { "Verdana", 16, "Regular Class", 0, 1.05 },
+                   { "Verdana", 9, "Regular Class", 0, 1.05 },
+                   { "Times New Roman", 16, "Regular Class", 'm', .95 },
+                   { "Trebuchet MS", 12, "Regular Class", 'm', .95 },
+                 };
+#else
+#define COMPATIBLE_WIDTHS_RULES_SIZE 1
+  SPH_TweakRule  COMPATIBLE_WIDTHS_Rules
+                   [COMPATIBLE_WIDTHS_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0 },
+                 };
+
+#define X_SCALING_RULES_SIZE 1
+  SPH_ScaleRule  X_SCALING_Rules
+                   [X_SCALING_RULES_SIZE] =
+                 {
+                   { "-", 0, "", 0, 1.0 },
+                 };
+#endif /* FORCE_NATURAL_WIDTHS */
+
+#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
+#endif /* __TTSUBPIX_H__ */
+
+/* END */
